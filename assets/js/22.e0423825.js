(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{540:function(s,n,a){"use strict";a.r(n);var t=a(8),e=Object(t.a)({},(function(){var s=this,n=s.$createElement,a=s._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"js基础"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js基础"}},[s._v("#")]),s._v(" JS基础")]),s._v(" "),a("h2",{attrs:{id:"_1-如何在es5环境下实现let"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-如何在es5环境下实现let"}},[s._v("#")]),s._v(" 1. 如何在ES5环境下实现let")]),s._v(" "),a("blockquote",[a("p",[s._v("这个问题实质上是在回答"),a("code",[s._v("let")]),s._v("和"),a("code",[s._v("var")]),s._v("有什么区别，对于这个问题，我们可以直接查看"),a("code",[s._v("babel")]),s._v("转换前后的结果，看一下在循环中通过"),a("code",[s._v("let")]),s._v("定义的变量是如何解决变量提升的问题")])]),s._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/4/5/1714616e2fd53bf8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:"img"}})]),s._v(" "),a("p",[s._v("babel在let定义的变量前加了道下划线，避免在块级作用域外访问到该变量，除了对变量名的转换，我们也可以通过自执行函数来模拟块级作用域")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("(function(){\n  for(var i = 0; i < 5; i ++){\n    console.log(i)  // 0 1 2 3 4\n  }\n})();\n\nconsole.log(i)      // Uncaught ReferenceError: i is not defined\n复制代码\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br")])]),a("p",[s._v("不过这个问题并没有结束，我们回到"),a("code",[s._v("var")]),s._v("和"),a("code",[s._v("let/const")]),s._v("的区别上：")]),s._v(" "),a("ul",[a("li",[a("code",[s._v("var")]),s._v("声明的变量会挂到window上，而"),a("code",[s._v("let")]),s._v("和"),a("code",[s._v("const")]),s._v("不会")]),s._v(" "),a("li",[a("code",[s._v("var")]),s._v("声明的变量存在变量提升，而"),a("code",[s._v("let")]),s._v("和"),a("code",[s._v("const")]),s._v("不会")]),s._v(" "),a("li",[a("code",[s._v("let")]),s._v("和"),a("code",[s._v("const")]),s._v("声明形成块作用域，只能在块作用域里访问，不能跨块访问，也不能跨函数访问")]),s._v(" "),a("li",[s._v("同一作用域下"),a("code",[s._v("let")]),s._v("和"),a("code",[s._v("const")]),s._v("不能声明同名变量，而"),a("code",[s._v("var")]),s._v("可以")]),s._v(" "),a("li",[s._v("暂时性死区，"),a("code",[s._v("let")]),s._v("和"),a("code",[s._v("const")]),s._v("声明的变量不能在声明前被使用")])]),s._v(" "),a("p",[s._v("babel的转化，其实只实现了第2、3、5点")]),s._v(" "),a("h2",{attrs:{id:"_2-如何在es5环境下实现const"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-如何在es5环境下实现const"}},[s._v("#")]),s._v(" 2. 如何在ES5环境下实现const")]),s._v(" "),a("p",[s._v("实现const的关键在于"),a("code",[s._v("Object.defineProperty()")]),s._v("这个API，这个API用于在一个对象上增加或修改属性。通过配置属性描述符，可以精确地控制属性行为。"),a("code",[s._v("Object.defineProperty()")]),s._v(" 接收三个参数：")]),s._v(" "),a("blockquote",[a("p",[s._v("Object.defineProperty(obj, prop, desc)")])]),s._v(" "),a("table",[a("thead",[a("tr",[a("th",[s._v("参数")]),s._v(" "),a("th",[s._v("说明")])])]),s._v(" "),a("tbody",[a("tr",[a("td",[s._v("obj")]),s._v(" "),a("td",[s._v("要在其上定义属性的对象")])]),s._v(" "),a("tr",[a("td",[s._v("prop")]),s._v(" "),a("td",[s._v("要定义或修改的属性的名称")])]),s._v(" "),a("tr",[a("td",[s._v("descriptor")]),s._v(" "),a("td",[s._v("将被定义或修改的属性描述符")])])])]),s._v(" "),a("table",[a("thead",[a("tr",[a("th",[s._v("属性描述符")]),s._v(" "),a("th",[s._v("说明")]),s._v(" "),a("th",[s._v("默认值")])])]),s._v(" "),a("tbody",[a("tr",[a("td",[s._v("value")]),s._v(" "),a("td",[s._v("该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined")]),s._v(" "),a("td",[s._v("undefined")])]),s._v(" "),a("tr",[a("td",[s._v("get")]),s._v(" "),a("td",[s._v("一个给属性提供 getter 的方法，如果没有 getter 则为 undefined")]),s._v(" "),a("td",[s._v("undefined")])]),s._v(" "),a("tr",[a("td",[s._v("set")]),s._v(" "),a("td",[s._v("一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。当属性值修改时，触发执行该方法")]),s._v(" "),a("td",[s._v("undefined")])]),s._v(" "),a("tr",[a("td",[s._v("writable")]),s._v(" "),a("td",[s._v("当且仅当该属性的writable为true时，value才能被赋值运算符改变。默认为 false")]),s._v(" "),a("td",[s._v("false")])]),s._v(" "),a("tr",[a("td",[s._v("enumerable")]),s._v(" "),a("td",[s._v("enumerable定义了对象的属性是否可以在 for...in 循环和 Object.keys() 中被枚举")]),s._v(" "),a("td",[s._v("false")])]),s._v(" "),a("tr",[a("td",[s._v("Configurable")]),s._v(" "),a("td",[s._v("configurable特性表示对象的属性是否可以被删除，以及除value和writable特性外的其他特性是否可以被修改")]),s._v(" "),a("td",[s._v("false")])])])]),s._v(" "),a("p",[s._v("对于const不可修改的特性，我们通过设置writable属性来实现")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("function _const(key, value) {    \n    const desc = {        \n        value,        \n        writable: false    \n    }    \n    Object.defineProperty(window, key, desc)\n}\n    \n_const('obj', {a: 1})   //定义obj\nobj.b = 2               //可以正常给obj的属性赋值\nobj = {}                //无法赋值新对象\n复制代码\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br")])]),a("p",[s._v("参考资料："),a("a",{attrs:{href:"https://juejin.im/post/6844903848008482824",target:"_blank",rel:"noopener noreferrer"}},[s._v("如何在 ES5 环境下实现一个const ？"),a("OutboundLink")],1)]),s._v(" "),a("h2",{attrs:{id:"_3-手写call"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-手写call"}},[s._v("#")]),s._v(" 3. 手写call()")]),s._v(" "),a("blockquote",[a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("call() 方法`使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数\n语法：`function.call(thisArg, arg1, arg2, ...)\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])])]),s._v(" "),a("p",[a("code",[s._v("call()")]),s._v("的原理比较简单，由于函数的this指向它的直接调用者，我们变更调用者即完成this指向的变更：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("//变更函数调用者示例\nfunction foo() {\n    console.log(this.name)\n}\n\n// 测试\nconst obj = {\n    name: '写代码像蔡徐抻'\n}\nobj.foo = foo   // 变更foo的调用者\nobj.foo()       // '写代码像蔡徐抻'\n复制代码\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br")])]),a("p",[s._v("基于以上原理, 我们两句代码就能实现call()")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("Function.prototype.myCall = function(thisArg, ...args) {\n    thisArg.fn = this              // this指向调用call的对象,即我们要改变this指向的函数\n    return thisArg.fn(...args)     // 执行函数并return其执行结果\n}\n复制代码\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br")])]),a("p",[s._v("但是我们有一些细节需要处理：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("Function.prototype.myCall = function(thisArg, ...args) {\n    const fn = Symbol('fn')        // 声明一个独有的Symbol属性, 防止fn覆盖已有属性\n    thisArg = thisArg || window    // 若没有传入this, 默认绑定window对象\n    thisArg[fn] = this              // this指向调用call的对象,即我们要改变this指向的函数\n    const result = thisArg[fn](...args)  // 执行当前函数\n    delete thisArg[fn]              // 删除我们声明的fn属性\n    return result                  // 返回函数执行结果\n}\n\n//测试\nfoo.myCall(obj)     // 输出'写代码像蔡徐抻'\n复制代码\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br")])]),a("h2",{attrs:{id:"_4-手写apply"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-手写apply"}},[s._v("#")]),s._v(" 4. 手写apply()")]),s._v(" "),a("blockquote",[a("p",[s._v("apply() 方法调用一个具有给定this值的函数，以及作为一个数组（或类似数组对象）提供的参数。\n语法：func.apply(thisArg, [argsArray])")])]),s._v(" "),a("p",[a("code",[s._v("apply()")]),s._v("和"),a("code",[s._v("call()")]),s._v("类似，区别在于call()接收参数列表，而apply()接收一个参数数组，所以我们在call()的实现上简单改一下入参形式即可")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("Function.prototype.myApply = function(thisArg, args) {\n    const fn = Symbol('fn')        // 声明一个独有的Symbol属性, 防止fn覆盖已有属性\n    thisArg = thisArg || window    // 若没有传入this, 默认绑定window对象\n    thisArg[fn] = this              // this指向调用call的对象,即我们要改变this指向的函数\n    const result = thisArg[fn](...args)  // 执行当前函数（此处说明一下：虽然apply()接收的是一个数组，但在调用原函数时，依然要展开参数数组。可以对照原生apply()，原函数接收到展开的参数数组）\n    delete thisArg[fn]              // 删除我们声明的fn属性\n    return result                  // 返回函数执行结果\n}\n\n//测试\nfoo.myApply(obj, [])     // 输出'写代码像蔡徐抻'\n复制代码\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br")])]),a("h2",{attrs:{id:"_5-手写bind"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-手写bind"}},[s._v("#")]),s._v(" 5. 手写bind()")]),s._v(" "),a("blockquote",[a("p",[a("code",[s._v("bind()")]),s._v(" 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。\n语法: function.bind(thisArg, arg1, arg2, ...)")])]),s._v(" "),a("p",[s._v("从用法上看，似乎给call/apply包一层function就实现了bind()：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("Function.prototype.myBind = function(thisArg, ...args) {\n    return () => {\n        this.apply(thisArg, args)\n    }\n}\n复制代码\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br")])]),a("p",[s._v("但我们忽略了三点：")]),s._v(" "),a("ol",[a("li",[s._v("bind()除了this还接收其他参数，bind()返回的函数也接收参数，这两部分的参数都要传给返回的函数")]),s._v(" "),a("li",[s._v("new会改变this指向：如果bind绑定后的函数被new了，那么this指向会发生改变，指向当前函数的实例")]),s._v(" "),a("li",[s._v("没有保留原函数在原型链上的属性和方法")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("Function.prototype.myBind = function (thisArg, ...args) {\n    var self = this\n    // new优先级\n    var fbound = function () {\n        self.apply(this instanceof self ? this : thisArg, args.concat(Array.prototype.slice.call(arguments)))\n    }\n    // 继承原型上的属性和方法\n    fbound.prototype = Object.create(self.prototype);\n\n    return fbound;\n}\n\n//测试\nconst obj = { name: '写代码像蔡徐抻' }\nfunction foo() {\n    console.log(this.name)\n    console.log(arguments)\n}\n\nfoo.myBind(obj, 'a', 'b', 'c')()    //输出写代码像蔡徐抻 ['a', 'b', 'c']\n复制代码\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br")])]),a("h2",{attrs:{id:"_6-手写一个防抖函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-手写一个防抖函数"}},[s._v("#")]),s._v(" 6. 手写一个防抖函数")]),s._v(" "),a("p",[s._v("防抖和节流的概念都比较简单，所以我们就不在“防抖节流是什么”这个问题上浪费过多篇幅了，简单点一下：")]),s._v(" "),a("blockquote",[a("p",[s._v("防抖，即"),a("code",[s._v("短时间内大量触发同一事件，只会执行一次函数")]),s._v("，实现原理为"),a("code",[s._v("设置一个定时器，约定在xx毫秒后再触发事件处理，每次触发事件都会重新设置计时器，直到xx毫秒内无第二次操作")]),s._v("，防抖常用于搜索框/滚动条的监听事件处理，如果不做防抖，每输入一个字/滚动屏幕，都会触发事件处理，造成性能浪费。")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("function debounce(func, wait) {\n    let timeout = null\n    return function() {\n        let context = this\n        let args = arguments\n        if (timeout) clearTimeout(timeout)\n        timeout = setTimeout(() => {\n            func.apply(context, args)\n        }, wait)\n    }\n}\n复制代码\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br")])]),a("h2",{attrs:{id:"_7-手写一个节流函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-手写一个节流函数"}},[s._v("#")]),s._v(" 7. 手写一个节流函数")]),s._v(" "),a("blockquote",[a("p",[s._v("防抖是"),a("code",[s._v("延迟执行")]),s._v("，而节流是"),a("code",[s._v("间隔执行")]),s._v("，函数节流即"),a("code",[s._v("每隔一段时间就执行一次")]),s._v("，实现原理为"),a("code",[s._v("设置一个定时器，约定xx毫秒后执行事件，如果时间到了，那么执行函数并重置定时器")]),s._v("，和防抖的区别在于，防抖每次触发事件都重置定时器，而节流在定时器到时间后再清空定时器")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("function throttle(func, wait) {\n    let timeout = null\n    return function() {\n        let context = this\n        let args = arguments\n        if (!timeout) {\n            timeout = setTimeout(() => {\n                timeout = null\n                func.apply(context, args)\n            }, wait)\n        }\n\n    }\n}\n复制代码\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br")])]),a("blockquote",[a("p",[s._v("实现方式2：使用两个时间戳"),a("code",[s._v("prev旧时间戳")]),s._v("和"),a("code",[s._v("now新时间戳")]),s._v("，每次触发事件都判断二者的时间差，如果到达规定时间，执行函数并重置旧时间戳")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("function throttle(func, wait) {\n    var prev = 0;\n    return function() {\n        let now = Date.now();\n        let context = this;\n        let args = arguments;\n        if (now - prev > wait) {\n            func.apply(context, args);\n            prev = now;\n        }\n    }\n}\n复制代码\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br")])]),a("h2",{attrs:{id:"_8-数组扁平化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-数组扁平化"}},[s._v("#")]),s._v(" 8. 数组扁平化")]),s._v(" "),a("blockquote",[a("p",[s._v("对于"),a("code",[s._v("[1, [1,2], [1,2,3]]")]),s._v("这样多层嵌套的数组，我们如何将其扁平化为"),a("code",[s._v("[1, 1, 2, 1, 2, 3]")]),s._v("这样的一维数组呢：")])]),s._v(" "),a("p",[a("strong",[s._v("1.ES6的flat()")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("const arr = [1, [1,2], [1,2,3]]\narr.flat(Infinity)  // [1, 1, 2, 1, 2, 3]\n复制代码\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])]),a("p",[a("strong",[s._v("2.序列化后正则")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("const arr = [1, [1,2], [1,2,3]]\nconst str = `[${JSON.stringify(arr).replace(/(\\[|\\])/g, '')}]`\nJSON.parse(str)   // [1, 1, 2, 1, 2, 3]\n复制代码\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("p",[a("strong",[s._v("3.递归")]),s._v("\n对于树状结构的数据，最直接的处理方式就是递归")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("const arr = [1, [1,2], [1,2,3]]\nfunction flat(arr) {\n  let result = []\n  for (const item of arr) {\n    item instanceof Array ? result = result.concat(flat(item)) : result.push(item)\n  }\n  return result\n}\n\nflat(arr) // [1, 1, 2, 1, 2, 3]\n复制代码\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br")])]),a("p",[a("strong",[s._v("4.reduce()递归")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("const arr = [1, [1,2], [1,2,3]]\nfunction flat(arr) {\n  return arr.reduce((prev, cur) => {\n    return prev.concat(cur instanceof Array ? flat(cur) : cur)\n  }, [])\n}\n\nflat(arr)  // [1, 1, 2, 1, 2, 3]\n复制代码\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br")])]),a("p",[a("strong",[s._v("5.迭代+展开运算符")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("// 每次while都会合并一层的元素，这里第一次合并结果为[1, 1, 2, 1, 2, 3, [4,4,4]]\n// 然后arr.some判定数组中是否存在数组，因为存在[4,4,4]，继续进入第二次循环进行合并\nlet arr = [1, [1,2], [1,2,3,[4,4,4]]]\nwhile (arr.some(Array.isArray)) {\n  arr = [].concat(...arr);\n}\n\nconsole.log(arr)  // [1, 1, 2, 1, 2, 3, 4, 4, 4]\n复制代码\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br")])]),a("h2",{attrs:{id:"_9-手写一个promise"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-手写一个promise"}},[s._v("#")]),s._v(" 9. 手写一个Promise")]),s._v(" "),a("blockquote",[a("p",[s._v("实现一个符合规范的Promise篇幅比较长，建议阅读笔者上一篇文章："),a("a",{attrs:{href:"https://juejin.im/post/6844904096525189128",target:"_blank",rel:"noopener noreferrer"}},[s._v("异步编程二三事 | Promise/async/Generator实现原理解析 | 9k字"),a("OutboundLink")],1)])]),s._v(" "),a("h1",{attrs:{id:"js面向对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js面向对象"}},[s._v("#")]),s._v(" JS面向对象")]),s._v(" "),a("p",[s._v("在JS中一切皆对象，但JS并不是一种真正的面向对象(OOP)的语言，因为它缺少"),a("code",[s._v("类(class)")]),s._v("的概念。虽然ES6引入了"),a("code",[s._v("class")]),s._v("和"),a("code",[s._v("extends")]),s._v("，使我们能够轻易地实现类和继承。但JS并不存在真实的类，JS的类是通过函数以及原型链机制模拟的，本小节的就来探究如何在ES5环境下利用函数和原型链实现JS面向对象的特性")]),s._v(" "),a("p",[s._v("在开始之前，我们先回顾一下原型链的知识，后续"),a("code",[s._v("new")]),s._v("和"),a("code",[s._v("继承")]),s._v("等实现都是基于原型链机制。很多介绍原型链的资料都能写上洋洋洒洒几千字，但我觉得读者们不需要把原型链想太复杂，容易把自己绕进去，其实在我看来，原型链的核心只需要记住三点：")]),s._v(" "),a("ol",[a("li",[s._v("每个对象都有"),a("code",[s._v("__proto__属性")]),s._v("，该属性指向其原型对象，在调用实例的方法和属性时，如果在实例对象上找不到，就会往原型对象上找")]),s._v(" "),a("li",[s._v("构造函数的"),a("code",[s._v("prototype属性")]),s._v("也指向实例的原型对象")]),s._v(" "),a("li",[s._v("原型对象的"),a("code",[s._v("constructor属性")]),s._v("指向构造函数")])]),s._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/4/4/17144d68b7d0eea1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:"img"}})]),s._v(" "),a("h2",{attrs:{id:"_1-模拟实现new"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-模拟实现new"}},[s._v("#")]),s._v(" 1. 模拟实现new")]),s._v(" "),a("p",[s._v("首先我们要知道"),a("code",[s._v("new")]),s._v("做了什么")]),s._v(" "),a("ol",[a("li",[a("strong",[s._v("创建一个新对象，并继承其构造函数的"),a("code",[s._v("prototype")])]),s._v("，这一步是为了继承构造函数原型上的属性和方法")]),s._v(" "),a("li",[a("strong",[s._v("执行构造函数，方法内的"),a("code",[s._v("this")]),s._v("被指定为该新实例")]),s._v("，这一步是为了执行构造函数内的赋值操作")]),s._v(" "),a("li",[a("strong",[s._v("返回新实例")]),s._v("（规范规定，如果构造方法返回了一个对象，那么返回该对象，否则返回第一步创建的新对象）")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("// new是关键字,这里我们用函数来模拟,new Foo(args) <=> myNew(Foo, args)\nfunction myNew(foo, ...args) {\n  // 创建新对象,并继承构造方法的prototype属性, 这一步是为了把obj挂原型链上, 相当于obj.__proto__ = Foo.prototype\n  let obj = Object.create(foo.prototype)  \n  \n  // 执行构造方法, 并为其绑定新this, 这一步是为了让构造方法能进行this.name = name之类的操作, args是构造方法的入参, 因为这里用myNew模拟, 所以入参从myNew传入\n  let result = foo.apply(obj, args)\n\n  // 如果构造方法已经return了一个对象，那么就返回该对象，否则返回myNew创建的新对象（一般情况下，构造方法不会返回新实例，但使用者可以选择返回新实例来覆盖new创建的对象）\n  return Object.prototype.toString.call(result) === '[object Object]' ? result : obj\n}\n\n// 测试：\nfunction Foo(name) {\n  this.name = name\n}\nconst newObj = myNew(Foo, 'zhangsan')\nconsole.log(newObj)                 // Foo {name: \"zhangsan\"}\nconsole.log(newObj instanceof Foo)  // true\n复制代码\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br")])]),a("h2",{attrs:{id:"_2-es5如何实现继承"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-es5如何实现继承"}},[s._v("#")]),s._v(" 2. ES5如何实现继承")]),s._v(" "),a("p",[s._v("说到继承，最容易想到的是ES6的"),a("code",[s._v("extends")]),s._v("，当然如果只回答这个肯定不合格，我们要从函数和原型链的角度上实现继承，下面我们一步步地、递进地实现一个合格的继承")]),s._v(" "),a("h3",{attrs:{id:"一-原型链继承"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一-原型链继承"}},[s._v("#")]),s._v(" 一. 原型链继承")]),s._v(" "),a("p",[s._v("原型链继承的原理很简单，直接让子类的原型对象指向父类实例，当子类实例找不到对应的属性和方法时，就会往它的原型对象，也就是父类实例上找，从而实现对父类的属性和方法的继承")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("// 父类\nfunction Parent() {\n    this.name = '写代码像蔡徐抻'\n}\n// 父类的原型方法\nParent.prototype.getName = function() {\n    return this.name\n}\n// 子类\nfunction Child() {}\n\n// 让子类的原型对象指向父类实例, 这样一来在Child实例中找不到的属性和方法就会到原型对象(父类实例)上寻找\nChild.prototype = new Parent()\nChild.prototype.constructor = Child // 根据原型链的规则,顺便绑定一下constructor, 这一步不影响继承, 只是在用到constructor时会需要\n\n// 然后Child实例就能访问到父类及其原型上的name属性和getName()方法\nconst child = new Child()\nchild.name          // '写代码像蔡徐抻'\nchild.getName()     // '写代码像蔡徐抻'\n复制代码\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br")])]),a("blockquote",[a("p",[s._v("原型继承的缺点:")])]),s._v(" "),a("ol",[a("li",[s._v("由于所有Child实例原型都指向同一个Parent实例, 因此对某个Child实例的父类引用类型变量修改会影响所有的Child实例")]),s._v(" "),a("li",[s._v("在创建子类实例时无法向父类构造传参, 即没有实现"),a("code",[s._v("super()")]),s._v("的功能")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("// 示例:\nfunction Parent() {\n    this.name = ['写代码像蔡徐抻'] \n}\nParent.prototype.getName = function() {\n    return this.name\n}\nfunction Child() {}\n\nChild.prototype = new Parent()\nChild.prototype.constructor = Child \n\n// 测试\nconst child1 = new Child()\nconst child2 = new Child()\nchild1.name[0] = 'foo'\nconsole.log(child1.name)          // ['foo']\nconsole.log(child2.name)          // ['foo'] (预期是['写代码像蔡徐抻'], 对child1.name的修改引起了所有child实例的变化)\n复制代码\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br")])]),a("h3",{attrs:{id:"二-构造函数继承"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二-构造函数继承"}},[s._v("#")]),s._v(" 二. 构造函数继承")]),s._v(" "),a("p",[s._v("构造函数继承，即在子类的构造函数中执行父类的构造函数，并为其绑定子类的"),a("code",[s._v("this")]),s._v("，让父类的构造函数把成员属性和方法都挂到"),a("code",[s._v("子类的this")]),s._v("上去，这样既能避免实例之间共享一个原型实例，又能向父类构造方法传参")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("function Parent(name) {\n    this.name = [name]\n}\nParent.prototype.getName = function() {\n    return this.name\n}\nfunction Child() {\n    Parent.call(this, 'zhangsan')   // 执行父类构造方法并绑定子类的this, 使得父类中的属性能够赋到子类的this上\n}\n\n//测试\nconst child1 = new Child()\nconst child2 = new Child()\nchild1.name[0] = 'foo'\nconsole.log(child1.name)          // ['foo']\nconsole.log(child2.name)          // ['zhangsan']\nchild2.getName()                  // 报错,找不到getName(), 构造函数继承的方式继承不到父类原型上的属性和方法\n复制代码\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br")])]),a("blockquote",[a("p",[s._v("构造函数继承的缺点:")])]),s._v(" "),a("ol",[a("li",[s._v("继承不到父类原型上的属性和方法")])]),s._v(" "),a("h3",{attrs:{id:"三-组合式继承"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三-组合式继承"}},[s._v("#")]),s._v(" 三. 组合式继承")]),s._v(" "),a("p",[s._v("既然原型链继承和构造函数继承各有互补的优缺点, 那么我们为什么不组合起来使用呢, 所以就有了综合二者的组合式继承")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("function Parent(name) {\n    this.name = [name]\n}\nParent.prototype.getName = function() {\n    return this.name\n}\nfunction Child() {\n    // 构造函数继承\n    Parent.call(this, 'zhangsan') \n}\n//原型链继承\nChild.prototype = new Parent()\nChild.prototype.constructor = Child\n\n//测试\nconst child1 = new Child()\nconst child2 = new Child()\nchild1.name[0] = 'foo'\nconsole.log(child1.name)          // ['foo']\nconsole.log(child2.name)          // ['zhangsan']\nchild2.getName()                  // ['zhangsan']\n复制代码\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br"),a("span",{staticClass:"line-number"},[s._v("22")]),a("br")])]),a("blockquote",[a("p",[s._v("组合式继承的缺点:")])]),s._v(" "),a("ol",[a("li",[s._v("每次创建子类实例都执行了两次构造函数("),a("code",[s._v("Parent.call()")]),s._v("和"),a("code",[s._v("new Parent()")]),s._v(")，虽然这并不影响对父类的继承，但子类创建实例时，原型中会存在两份相同的属性和方法，这并不优雅")])]),s._v(" "),a("h3",{attrs:{id:"四-寄生式组合继承"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四-寄生式组合继承"}},[s._v("#")]),s._v(" 四. 寄生式组合继承")]),s._v(" "),a("p",[s._v("为了解决构造函数被执行两次的问题, 我们将"),a("code",[s._v("指向父类实例")]),s._v("改为"),a("code",[s._v("指向父类原型")]),s._v(", 减去一次构造函数的执行")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("function Parent(name) {\n    this.name = [name]\n}\nParent.prototype.getName = function() {\n    return this.name\n}\nfunction Child() {\n    // 构造函数继承\n    Parent.call(this, 'zhangsan') \n}\n//原型链继承\n// Child.prototype = new Parent()\nChild.prototype = Parent.prototype  //将`指向父类实例`改为`指向父类原型`\nChild.prototype.constructor = Child\n\n//测试\nconst child1 = new Child()\nconst child2 = new Child()\nchild1.name[0] = 'foo'\nconsole.log(child1.name)          // ['foo']\nconsole.log(child2.name)          // ['zhangsan']\nchild2.getName()                  // ['zhangsan']\n复制代码\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br"),a("span",{staticClass:"line-number"},[s._v("22")]),a("br"),a("span",{staticClass:"line-number"},[s._v("23")]),a("br")])]),a("p",[s._v("但这种方式存在一个问题，由于子类原型和父类原型指向同一个对象，我们对子类原型的操作会影响到父类原型，例如给"),a("code",[s._v("Child.prototype")]),s._v("增加一个getName()方法，那么会导致"),a("code",[s._v("Parent.prototype")]),s._v("也增加或被覆盖一个getName()方法，为了解决这个问题，我们给"),a("code",[s._v("Parent.prototype")]),s._v("做一个浅拷贝")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("function Parent(name) {\n    this.name = [name]\n}\nParent.prototype.getName = function() {\n    return this.name\n}\nfunction Child() {\n    // 构造函数继承\n    Parent.call(this, 'zhangsan') \n}\n//原型链继承\n// Child.prototype = new Parent()\nChild.prototype = Object.create(Parent.prototype)  //将`指向父类实例`改为`指向父类原型`\nChild.prototype.constructor = Child\n\n//测试\nconst child = new Child()\nconst parent = new Parent()\nchild.getName()                  // ['zhangsan']\nparent.getName()                 // 报错, 找不到getName()\n复制代码\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br")])]),a("p",[s._v("到这里我们就完成了ES5环境下的继承的实现，这种继承方式称为"),a("code",[s._v("寄生组合式继承")]),s._v("，是目前最成熟的继承方式，babel对ES6继承的转化也是使用了寄生组合式继承")]),s._v(" "),a("p",[s._v("我们回顾一下实现过程：\n一开始最容易想到的是"),a("code",[s._v("原型链继承")]),s._v("，通过把子类实例的原型指向父类实例来继承父类的属性和方法，但原型链继承的缺陷在于"),a("code",[s._v("对子类实例继承的引用类型的修改会影响到所有的实例对象")]),s._v("以及"),a("code",[s._v("无法向父类的构造方法传参")]),s._v("。\n因此我们引入了"),a("code",[s._v("构造函数继承")]),s._v(", 通过在子类构造函数中调用父类构造函数并传入子类this来获取父类的属性和方法，但构造函数继承也存在缺陷，构造函数继承"),a("code",[s._v("不能继承到父类原型链上的属性和方法")]),s._v("。\n所以我们综合了两种继承的优点，提出了"),a("code",[s._v("组合式继承")]),s._v("，但组合式继承也引入了新的问题，它"),a("code",[s._v("每次创建子类实例都执行了两次父类构造方法")]),s._v("，我们通过将"),a("code",[s._v("子类原型指向父类实例")]),s._v("改为"),a("code",[s._v("子类原型指向父类原型的浅拷贝")]),s._v("来解决这一问题，也就是最终实现 —— "),a("code",[s._v("寄生组合式继承")])]),s._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/4/6/1714fd86c8983189?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:"img"}})]),s._v(" "),a("h1",{attrs:{id:"v8引擎机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#v8引擎机制"}},[s._v("#")]),s._v(" V8引擎机制")]),s._v(" "),a("h2",{attrs:{id:"_1-v8如何执行一段js代码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-v8如何执行一段js代码"}},[s._v("#")]),s._v(" 1. V8如何执行一段JS代码")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/2/5/1701324268cca319?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:"img"}})]),s._v(" "),a("ol",[a("li",[a("strong",[s._v("预解析")]),s._v("：检查语法错误但不生成AST")]),s._v(" "),a("li",[a("strong",[s._v("生成AST")]),s._v("：经过词法/语法分析，生成抽象语法树")]),s._v(" "),a("li",[a("strong",[s._v("生成字节码")]),s._v("：基线编译器(Ignition)将AST转换成字节码")]),s._v(" "),a("li",[a("strong",[s._v("生成机器码")]),s._v("：优化编译器(Turbofan)将字节码转换成优化过的机器码，此外在逐行执行字节码的过程中，如果一段代码经常被执行，那么V8会将这段代码直接转换成机器码保存起来，下一次执行就不必经过字节码，优化了执行速度")])]),s._v(" "),a("p",[s._v("上面几点只是V8执行机制的极简总结，建议阅读参考资料：")]),s._v(" "),a("blockquote",[a("p",[s._v("1."),a("a",{attrs:{href:"https://juejin.im/post/6844903990073753613",target:"_blank",rel:"noopener noreferrer"}},[s._v("V8 是怎么跑起来的 —— V8 的 JavaScript 执行管道"),a("OutboundLink")],1),s._v("\n2."),a("a",{attrs:{href:"https://juejin.im/post/6844904021451505677",target:"_blank",rel:"noopener noreferrer"}},[s._v("JavaScript 引擎 V8 执行流程概述"),a("OutboundLink")],1)])]),s._v(" "),a("h2",{attrs:{id:"_2-介绍一下引用计数和标记清除"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-介绍一下引用计数和标记清除"}},[s._v("#")]),s._v(" 2. 介绍一下引用计数和标记清除")]),s._v(" "),a("ul",[a("li",[a("strong",[s._v("引用计数")]),s._v("：给一个变量赋值引用类型，则该对象的引用次数+1，如果这个变量变成了其他值，那么该对象的引用次数-1，垃圾回收器会回收引用次数为0的对象。但是当对象循环引用时，会导致引用次数永远无法归零，造成内存无法释放。")]),s._v(" "),a("li",[a("strong",[s._v("标记清除")]),s._v("：垃圾收集器先给内存中所有对象加上标记，然后从根节点开始遍历，去掉被引用的对象和运行环境中对象的标记，剩下的被标记的对象就是无法访问的等待回收的对象。")])]),s._v(" "),a("h2",{attrs:{id:"_3-v8如何进行垃圾回收"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-v8如何进行垃圾回收"}},[s._v("#")]),s._v(" 3. V8如何进行垃圾回收")]),s._v(" "),a("p",[s._v("JS引擎中对变量的存储主要有两种位置，栈内存和堆内存，栈内存存储基本类型数据以及引用类型数据的内存地址，堆内存储存引用类型的数据")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/4/5/17149730709e41a4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:"img"}})]),s._v(" "),a("blockquote",[a("p",[s._v("栈内存的回收：")])]),s._v(" "),a("p",[s._v("栈内存调用栈上下文切换后就被回收，比较简单")]),s._v(" "),a("blockquote",[a("p",[s._v("堆内存的回收：")])]),s._v(" "),a("p",[s._v("V8的堆内存分为新生代内存和老生代内存，新生代内存是临时分配的内存，存在时间短，老生代内存存在时间长")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/4/5/1714980cac75fc32?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:"img"}})]),s._v(" "),a("ul",[a("li",[s._v("新生代内存回收机制：\n"),a("ul",[a("li",[s._v("新生代内存容量小，64位系统下仅有32M。新生代内存分为"),a("strong",[s._v("From、To")]),s._v("两部分，进行垃圾回收时，先扫描From，将非存活对象回收，将存活对象顺序复制到To中，之后调换From/To，等待下一次回收")])])]),s._v(" "),a("li",[s._v("老生代内存回收机制\n"),a("ul",[a("li",[a("strong",[s._v("晋升")]),s._v("：如果新生代的变量经过多次回收依然存在，那么就会被放入老生代内存中")]),s._v(" "),a("li",[a("strong",[s._v("标记清除")]),s._v("：老生代内存会先遍历所有对象并打上标记，然后对正在使用或被强引用的对象取消标记，回收被标记的对象")]),s._v(" "),a("li",[a("strong",[s._v("整理内存碎片")]),s._v("：把对象挪到内存的一端")])])])]),s._v(" "),a("blockquote",[a("p",[s._v("参考资料："),a("a",{attrs:{href:"https://juejin.im/post/6844903591510016007#heading-10",target:"_blank",rel:"noopener noreferrer"}},[s._v("聊聊V8引擎的垃圾回收"),a("OutboundLink")],1)])]),s._v(" "),a("h2",{attrs:{id:"_4-js相较于c-等语言为什么慢，v8做了哪些优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-js相较于c-等语言为什么慢，v8做了哪些优化"}},[s._v("#")]),s._v(" 4. JS相较于C++等语言为什么慢，V8做了哪些优化")]),s._v(" "),a("ol",[a("li",[s._v("JS的问题：\n"),a("ul",[a("li",[a("strong",[s._v("动态类型")]),s._v("：导致每次存取属性/寻求方法时候，都需要先检查类型；此外动态类型也很难在编译阶段进行优化")]),s._v(" "),a("li",[a("strong",[s._v("属性存取")]),s._v("：C++/Java等语言中方法、属性是存储在数组中的，仅需数组位移就可以获取，而JS存储在对象中，每次获取都要进行哈希查询")])])]),s._v(" "),a("li",[s._v("V8的优化：\n"),a("ul",[a("li",[a("strong",[s._v("优化JIT(即时编译)")]),s._v("：相较于C++/Java这类编译型语言，JS一边解释一边执行，效率低。V8对这个过程进行了优化：如果一段代码被执行多次，那么V8会把这段代码转化为机器码缓存下来，下次运行时直接使用机器码。")]),s._v(" "),a("li",[a("strong",[s._v("隐藏类")]),s._v("：对于C++这类语言来说，仅需几个指令就能通过偏移量获取变量信息，而JS需要进行字符串匹配，效率低，V8借用了类和偏移位置的思想，将对象划分成不同的组，即隐藏类")]),s._v(" "),a("li",[a("strong",[s._v("内嵌缓存")]),s._v("：即缓存对象查询的结果。常规查询过程是：获取隐藏类地址 -> 根据属性名查找偏移值 -> 计算该属性地址，内嵌缓存就是对这一过程结果的缓存")]),s._v(" "),a("li",[a("strong",[s._v("垃圾回收管理")]),s._v("：上文已介绍")])])])]),s._v(" "),a("p",[s._v('![img](data:image/svg+xml;utf8,<?xml version="1.0"?>'),a("svg",{attrs:{xmlns:"http://www.w3.org/2000/svg",version:"1.1",width:"1280",height:"824"}}),s._v(")")]),s._v(" "),a("blockquote",[a("p",[s._v("参考资料："),a("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/27628685",target:"_blank",rel:"noopener noreferrer"}},[s._v("为什么V8引擎这么快？"),a("OutboundLink")],1)])]),s._v(" "),a("h1",{attrs:{id:"浏览器渲染机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器渲染机制"}},[s._v("#")]),s._v(" 浏览器渲染机制")]),s._v(" "),a("h2",{attrs:{id:"_1-浏览器的渲染过程是怎样的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-浏览器的渲染过程是怎样的"}},[s._v("#")]),s._v(" 1. 浏览器的渲染过程是怎样的")]),s._v(" "),a("p",[s._v('![img](data:image/svg+xml;utf8,<?xml version="1.0"?>'),a("svg",{attrs:{xmlns:"http://www.w3.org/2000/svg",version:"1.1",width:"1280",height:"604"}}),s._v(")")]),s._v(" "),a("p",[s._v("大体流程如下：")]),s._v(" "),a("ol",[a("li",[s._v("HTML和CSS经过各自解析，生成DOM树和CSSOM树")]),s._v(" "),a("li",[s._v("合并成为渲染树")]),s._v(" "),a("li",[s._v("根据渲染树进行布局")]),s._v(" "),a("li",[s._v("最后调用GPU进行绘制，显示在屏幕上")])]),s._v(" "),a("h2",{attrs:{id:"_2-如何根据浏览器渲染机制加快首屏速度"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-如何根据浏览器渲染机制加快首屏速度"}},[s._v("#")]),s._v(" 2. 如何根据浏览器渲染机制加快首屏速度")]),s._v(" "),a("ol",[a("li",[a("strong",[s._v("优化文件大小")]),s._v("：HTML和CSS的加载和解析都会阻塞渲染树的生成，从而影响首屏展示速度，因此我们可以通过优化文件大小、减少CSS文件层级的方法来加快首屏速度")]),s._v(" "),a("li",[a("strong",[s._v("避免资源下载阻塞文档解析")]),s._v("：浏览器解析到"),a("script")])])])}),[],!1,null,null,null);n.default=e.exports}}]);