(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{550:function(n,s,e){"use strict";e.r(s);var t=e(8),a=Object(t.a)({},(function(){var n=this,s=n.$createElement,e=n._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h2",{attrs:{id:"打造高性能的-react-应用的几种方式总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#打造高性能的-react-应用的几种方式总结"}},[n._v("#")]),n._v(" 打造高性能的 React 应用的几种方式总结")]),n._v(" "),e("ul",[e("li",[n._v("使用 "),e("code",[n._v("shouldComponentUpdate")]),n._v(" 规避冗余的更新逻辑")]),n._v(" "),e("li",[e("code",[n._v("PureComponent + Immutable.js")])]),n._v(" "),e("li",[e("code",[n._v("React.memo")]),n._v(" 与 "),e("code",[n._v("useMemo")])])]),n._v(" "),e("blockquote",[e("p",[n._v("注：这 3 个思路同时也是 React 面试中“性能优化”这一环的核心所在")])]),n._v(" "),e("h2",{attrs:{id:"善用-shouldcomponentupdate"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#善用-shouldcomponentupdate"}},[n._v("#")]),n._v(" 善用 shouldComponentUpdate")]),n._v(" "),e("p",[e("code",[n._v("shouldComponentUpdate")]),n._v(" 的调用形式如下：")]),n._v(" "),e("div",{staticClass:"language-react line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("shouldComponentUpdate(nextProps, nextState)\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br")])]),e("blockquote",[e("ul",[e("li",[e("code",[n._v("render")]),n._v(" 方法由于伴随着对虚拟 "),e("code",[n._v("DOM")]),n._v(" 的构建和对比，过程可以说相当耗时。而在 "),e("code",[n._v("React")]),n._v(" 当中，很多时候我们会不经意间就频繁地调用了 "),e("code",[n._v("render")]),n._v("。为了避免不必要的 "),e("code",[n._v("render")]),n._v(" 操作带来的性能开销，React 提供了 "),e("code",[n._v("shouldComponentUpdate")]),n._v(" 这个口子。React 组件会根据 "),e("code",[n._v("shouldComponentUpdate")]),n._v(" 的返回值，来决定是否执行该方法之后的生命周期，进而决定是否对组件进行 "),e("code",[n._v("re-render")]),n._v("（重渲染）。")]),n._v(" "),e("li",[e("code",[n._v("shouldComponentUpdate")]),n._v(" 的默认值为 "),e("code",[n._v("true")]),n._v("，也就是说 “无条件 re-render”。在实际的开发中，我们往往通过手动往 "),e("code",[n._v("shouldComponentUpdate")]),n._v(" 中填充判定逻辑，来实现“有条件的 re-render”。")])])]),n._v(" "),e("p",[n._v("首先我们来看两个子组件的代码，这里为了尽量简化与数据变更无关的逻辑，ChildA 和 ChildB 都只负责从父组件处读取数据并渲染，它们的编码分别如下所示。")]),n._v(" "),e("div",{staticClass:"language-react line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('// ChildA.js：\n\nimport React from "react";\nexport default class ChildA extends React.Component {\n  render() {\n    console.log("ChildA 的render方法执行了");\n    return (\n      <div className="childA">\n        子组件A的内容：\n        {this.props.text}\n      </div>\n    );\n  }\n}\n// ChildB.js：\n\nimport React from "react";\nexport default class ChildB extends React.Component {\n  render() {\n    console.log("ChildB 的render方法执行了");\n    return (\n      <div className="childB">\n        子组件B的内容：\n        {this.props.text}\n      </div>\n    );\n  }\n}\n// 在共同的父组件 App.js 中，会将 ChildA 和 ChildB 组合起来，并分别向其中注入数据：\n\nimport React from "react";\nimport ChildA from \'./ChildA\'\nimport ChildB from \'./ChildB\'\nclass App extends React.Component {\n  state = {\n    textA: \'我是A的文本\',\n    textB: \'我是B的文本\'\n  }\n  changeA = () => {\n    this.setState({\n      textA: \'A的文本被修改了\'\n    })\n  }\n  changeB = () => {\n    this.setState({\n      textB: \'B的文本被修改了\'\n    })\n  }\n  render() {\n    return (\n    <div className="App">\n      <div className="container">\n        <button onClick={this.changeA}>点击修改A处的文本</button>\n        <button onClick={this.changeB}>点击修改B处的文本</button>\n        <ul>\n          <li>\n            <ChildA text={this.state.textA}/>\n          </li>\n        <li>\n          <ChildB text={this.state.textB}/>\n        </li>\n        </ul>\n      </div>\n    </div>\n  );\n  }\n}\nexport default App;\n')])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br"),e("span",{staticClass:"line-number"},[n._v("9")]),e("br"),e("span",{staticClass:"line-number"},[n._v("10")]),e("br"),e("span",{staticClass:"line-number"},[n._v("11")]),e("br"),e("span",{staticClass:"line-number"},[n._v("12")]),e("br"),e("span",{staticClass:"line-number"},[n._v("13")]),e("br"),e("span",{staticClass:"line-number"},[n._v("14")]),e("br"),e("span",{staticClass:"line-number"},[n._v("15")]),e("br"),e("span",{staticClass:"line-number"},[n._v("16")]),e("br"),e("span",{staticClass:"line-number"},[n._v("17")]),e("br"),e("span",{staticClass:"line-number"},[n._v("18")]),e("br"),e("span",{staticClass:"line-number"},[n._v("19")]),e("br"),e("span",{staticClass:"line-number"},[n._v("20")]),e("br"),e("span",{staticClass:"line-number"},[n._v("21")]),e("br"),e("span",{staticClass:"line-number"},[n._v("22")]),e("br"),e("span",{staticClass:"line-number"},[n._v("23")]),e("br"),e("span",{staticClass:"line-number"},[n._v("24")]),e("br"),e("span",{staticClass:"line-number"},[n._v("25")]),e("br"),e("span",{staticClass:"line-number"},[n._v("26")]),e("br"),e("span",{staticClass:"line-number"},[n._v("27")]),e("br"),e("span",{staticClass:"line-number"},[n._v("28")]),e("br"),e("span",{staticClass:"line-number"},[n._v("29")]),e("br"),e("span",{staticClass:"line-number"},[n._v("30")]),e("br"),e("span",{staticClass:"line-number"},[n._v("31")]),e("br"),e("span",{staticClass:"line-number"},[n._v("32")]),e("br"),e("span",{staticClass:"line-number"},[n._v("33")]),e("br"),e("span",{staticClass:"line-number"},[n._v("34")]),e("br"),e("span",{staticClass:"line-number"},[n._v("35")]),e("br"),e("span",{staticClass:"line-number"},[n._v("36")]),e("br"),e("span",{staticClass:"line-number"},[n._v("37")]),e("br"),e("span",{staticClass:"line-number"},[n._v("38")]),e("br"),e("span",{staticClass:"line-number"},[n._v("39")]),e("br"),e("span",{staticClass:"line-number"},[n._v("40")]),e("br"),e("span",{staticClass:"line-number"},[n._v("41")]),e("br"),e("span",{staticClass:"line-number"},[n._v("42")]),e("br"),e("span",{staticClass:"line-number"},[n._v("43")]),e("br"),e("span",{staticClass:"line-number"},[n._v("44")]),e("br"),e("span",{staticClass:"line-number"},[n._v("45")]),e("br"),e("span",{staticClass:"line-number"},[n._v("46")]),e("br"),e("span",{staticClass:"line-number"},[n._v("47")]),e("br"),e("span",{staticClass:"line-number"},[n._v("48")]),e("br"),e("span",{staticClass:"line-number"},[n._v("49")]),e("br"),e("span",{staticClass:"line-number"},[n._v("50")]),e("br"),e("span",{staticClass:"line-number"},[n._v("51")]),e("br"),e("span",{staticClass:"line-number"},[n._v("52")]),e("br"),e("span",{staticClass:"line-number"},[n._v("53")]),e("br"),e("span",{staticClass:"line-number"},[n._v("54")]),e("br"),e("span",{staticClass:"line-number"},[n._v("55")]),e("br"),e("span",{staticClass:"line-number"},[n._v("56")]),e("br"),e("span",{staticClass:"line-number"},[n._v("57")]),e("br"),e("span",{staticClass:"line-number"},[n._v("58")]),e("br"),e("span",{staticClass:"line-number"},[n._v("59")]),e("br"),e("span",{staticClass:"line-number"},[n._v("60")]),e("br"),e("span",{staticClass:"line-number"},[n._v("61")]),e("br"),e("span",{staticClass:"line-number"},[n._v("62")]),e("br"),e("span",{staticClass:"line-number"},[n._v("63")]),e("br"),e("span",{staticClass:"line-number"},[n._v("64")]),e("br"),e("span",{staticClass:"line-number"},[n._v("65")]),e("br"),e("span",{staticClass:"line-number"},[n._v("66")]),e("br"),e("span",{staticClass:"line-number"},[n._v("67")]),e("br"),e("span",{staticClass:"line-number"},[n._v("68")]),e("br")])]),e("p",[n._v("App 组件最终渲染到界面上的效果如下图所示，两个子组件在图中分别被不同颜色的标注圈出：")]),n._v(" "),e("p",[e("img",{attrs:{src:"https://mmbiz.qpic.cn/sz_mmbiz_png/zHYsKHjf0njMyqe5C52rtuldYXB5qI1ib01KPPoNWasRPH53drURE5ibeniaQBhA9Jm5eUGDLW1rrUGpjHqBL5O1Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),n._v(" "),e("p",[n._v("通过点击左右两个按钮，我们可以分别对 ChildA 和 ChildB 中的文案进行修改。")]),n._v(" "),e("p",[n._v("由于初次渲染时，两个组件的 render 函数都必然会被触发，因此控制台在挂载完成后的输出内容如下图所示：")]),n._v(" "),e("p",[e("img",{attrs:{src:"https://mmbiz.qpic.cn/sz_mmbiz_png/zHYsKHjf0njMyqe5C52rtuldYXB5qI1ibDiaW3ibWuPajnZgTVObflpbFSzSXN9UXeGiayOr3zjIqaZ2sC56nX15vA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),n._v(" "),e("p",[n._v("接下来我点击左侧的按钮，尝试对 A 处的文本进行修改。我们可以看到界面上只有 A 处的渲染效果发生了改变，如下图箭头处所示：")]),n._v(" "),e("p",[e("img",{attrs:{src:"https://mmbiz.qpic.cn/sz_mmbiz_png/zHYsKHjf0njMyqe5C52rtuldYXB5qI1ibeP1Cj5V2iaDDIJsoOaKXdza53njOWribYIQibBECLz2PvGrNFhVTHYjhg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),n._v(" "),e("p",[n._v("但是如果我们打开控制台，会发现输出的内容如下图所示：")]),n._v(" "),e("p",[e("img",{attrs:{src:"https://mmbiz.qpic.cn/sz_mmbiz_png/zHYsKHjf0njMyqe5C52rtuldYXB5qI1ibuWUUP5iawE0HUDfTkr6ChxXlECQlicKSsA9L2kF3lmMDQXaf814slIZQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),n._v(" "),e("p",[n._v("这样的输出结果告诉我们，在刚刚的点击动作后，不仅 ChildA 的 re-render 被触发了，ChildB 的 re-render 也被触发了。")]),n._v(" "),e("blockquote",[e("p",[n._v("在 React 中，"),e("code",[n._v("只要父组件发生了更新，那么所有的子组件都会被无条件更新")]),n._v("。这就导致了 ChildB 的 props 尽管没有发生任何变化，它本身也没有任何需要被更新的点，却还是会走一遍更新流程。")])]),n._v(" "),e("p",[e("strong",[n._v("注：")]),n._v(" "),e("code",[n._v("同样的情况也适用于组件自身的更新：当组件自身调用了 setState 后，那么不管 setState 前后的状态内容是否真正发生了变化，它都会去走一遍更新流程")]),n._v("。")]),n._v(" "),e("p",[n._v("而在刚刚这个更新流程中，"),e("code",[n._v("shouldComponentUpdate")]),n._v(" 函数没有被手动定义，因此它将返回“true”这个默认值。“true”则意味着对更新流程不作任何制止，也即所谓的“无条件 re-render”。在这种情况下，我们就可以考虑使用 "),e("code",[n._v("shouldComponentUpdate")]),n._v(" 来对更新过程进行管控，避免没有意义的 re-render 发生。")]),n._v(" "),e("p",[n._v("现在我们就可以为 ChildB 加装这样一段 "),e("code",[n._v("shouldComponentUpdate")]),n._v(" 逻辑：")]),n._v(" "),e("div",{staticClass:"language-react line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("shouldComponentUpdate(nextProps, nextState) {\n  // 判断 text 属性在父组件更新前后有没有发生变化，若没有发生变化，则返回 false\n  if(nextProps.text === this.props.text) {\n    return false\n  }\n  // 只有在 text 属性值确实发生变化时，才允许更新进行下去\n  return true\n}\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br")])]),e("p",[n._v("在这段逻辑中，我们对 ChildB 中的可变数据，也就是 this.props.text 这个属性进行了判断。")]),n._v(" "),e("p",[n._v("这样，当父组件 App 组件发生更新、进而试图触发 ChildB 的更新流程时，shouldComponentUpdate 就会充当一个“守门员”的角色：它会检查新下发的 "),e("code",[n._v("props.text")]),n._v(" 是否和之前的值一致，如果一致，那么就没有更新的必要，直接返回“false”将整个 ChildB 的更新生命周期中断掉即可。只有当 props.text 确实发生变化时，它才会“准许” re-render 的发生。")]),n._v(" "),e("p",[n._v("在 "),e("code",[n._v("shouldComponentUpdate")]),n._v(" 的加持下，当我们再次点击左侧按钮，试图修改 ChildA 的渲染内容时，控制台的输出就会变成下图这样：")]),n._v(" "),e("p",[e("img",{attrs:{src:"https://mmbiz.qpic.cn/sz_mmbiz_png/zHYsKHjf0njMyqe5C52rtuldYXB5qI1ibdxNiby3WmoxDk0DGSck6IC6ia08YCW4DvAAhJKc2xaK0hhjHLZ9GpicZg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),n._v(" "),e("p",[n._v("我们看到，控制台中现在只有 ChildA 的 re-render 提示。ChildB “稳如泰山”，成功躲开了一次多余的渲染。")]),n._v(" "),e("p",[n._v("使用 "),e("code",[n._v("shouldComponentUpdate")]),n._v(" 来调停不必要的更新，避免无意义的 re-render 发生，这是 React 组件中最基本的性能优化手段，也是最重要的手段。许多看似高级的玩法，都是基于 "),e("code",[n._v("shouldComponentUpdate")]),n._v(" 衍生出来的。我们接下来要讲的 "),e("code",[n._v("PureComponent")]),n._v("，就是这类玩法中的典型。")]),n._v(" "),e("h2",{attrs:{id:"进阶玩法：purecomponent-immutable-js"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#进阶玩法：purecomponent-immutable-js"}},[n._v("#")]),n._v(" 进阶玩法：PureComponent + Immutable.js")]),n._v(" "),e("p",[e("strong",[n._v("PureComponent：提前帮你安排好更新判定逻辑")])]),n._v(" "),e("blockquote",[e("p",[e("code",[n._v("shouldComponentUpdate")]),n._v(" 虽然一定程度上帮我们解决了性能方面的问题，但每次避免 re-render，都要手动实现一次 "),e("code",[n._v("shouldComponentUpdate")]),n._v("，未免太累了。作为一个不喜欢重复劳动的前端开发者来说，在写了不计其数个 "),e("code",[n._v("shouldComponentUpdate")]),n._v(" 逻辑之后，难免会怀疑人生")])]),n._v(" "),e("p",[e("code",[n._v("React 15.3")]),n._v(" 很明显听到了开发者的声音，它新增了一个叫 "),e("code",[n._v("PureComponent")]),n._v(" 的类，恰到好处地解决了“程序员写 "),e("code",[n._v("shouldComponentUpdate")]),n._v(" 写出腱鞘炎”这个问题。")]),n._v(" "),e("blockquote",[e("p",[e("code",[n._v("PureComponent 与 Component 的区别点")]),n._v("，就在于它内置了对 "),e("code",[n._v("shouldComponentUpdate")]),n._v(" 的实现："),e("code",[n._v("PureComponent")]),n._v(" 将会在 "),e("code",[n._v("shouldComponentUpdate")]),n._v(" 中对组件更新前后的 "),e("code",[n._v("props 和 state 进行浅比较")]),n._v("，并根据浅比较的结果，决定是否需要继续更新流程。")])]),n._v(" "),e("div",{staticClass:"language-react line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('import React from "react";\nexport default class ChildB extends React.PureComponent {\n  render() {\n    console.log("ChildB 的render方法执行了");\n    return (\n      <div className="childB">\n        子组件B的内容：\n        {this.props.text}\n      </div>\n    );\n  }\n}\n')])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br"),e("span",{staticClass:"line-number"},[n._v("9")]),e("br"),e("span",{staticClass:"line-number"},[n._v("10")]),e("br"),e("span",{staticClass:"line-number"},[n._v("11")]),e("br"),e("span",{staticClass:"line-number"},[n._v("12")]),e("br")])]),e("p",[n._v("此时再去修改 ChildA 中的文本，我们会发现 ChildB 同样不受影响")]),n._v(" "),e("blockquote",[e("p",[n._v("在值类型数据这种场景下，"),e("code",[n._v("PureComponent")]),n._v(" 可以说是战无不胜。但是如果数据类型为引用类型，那么这种基于浅比较的判断逻辑就会带来这样两个风险：")])]),n._v(" "),e("ul",[e("li",[n._v("若数据内容没变，但是引用变了，那么浅比较仍然会认为“数据发生了变化”，进而触发一次不必要的更新，导致过度渲染；")]),n._v(" "),e("li",[n._v("若数据内容变了，但是引用没变，那么浅比较则会认为“数据没有发生变化”，进而阻断一次更新，导致不渲染。")])]),n._v(" "),e("p",[n._v("怎么办呢？"),e("code",[n._v("Immutable.js")]),n._v(" 来帮忙！")]),n._v(" "),e("p",[e("strong",[n._v("Immutable：“不可变值”让“变化”无处遁形")])]),n._v(" "),e("blockquote",[e("p",[e("code",[n._v("PureComponent 浅比较带来的问题，本质上是对“变化”的判断不够精准导致的")]),n._v("。那有没有一种办法，能够让引用的变化和内容的变化之间，建立一种必然的联系呢？")])]),n._v(" "),e("p",[n._v("这就是 "),e("code",[n._v("Immutable.js")]),n._v(" 所做的事情。")]),n._v(" "),e("p",[n._v("Immutable 直译过来是“不可变的”，顾名思义，Immutable.js 是对“不可变值”这一思想的贯彻实践。它在 2014 年被 Facebook 团队推出，Facebook 给它的定位是“实现持久性数据结构的库”。所谓“持久性数据”，指的是这个数据只要被创建出来了，就不能被更改。我们对当前数据的任何修改动作，都会导致一个新的对象的返回。这就将数据内容的变化和数据的引用严格地关联了起来，使得“变化”无处遁形。")]),n._v(" "),e("p",[n._v("这里我用一个简单的例子，来演示一下 Immutable.js 的效果。请看下面代码：")]),n._v(" "),e("div",{staticClass:"language-react line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("// 引入 immutable 库里的 Map 对象，它用于创建对象\nimport { Map } from 'immutable'\n// 初始化一个对象 baseMap\nconst baseMap = Map({\n  name: 'po',\n  career: 'fe',\n  age: 99\n})\n// 使用 immutable 暴露的 Api 来修改 baseMap 的内容\nconst changedMap = baseMap.set({\n  age: 100\n})\n// 我们会发现修改 baseMap 后将会返回一个新的对象，这个对象的引用和 baseMap 是不同的\nconsole.log('baseMap === changedMap', baseMap === changedMap)\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br"),e("span",{staticClass:"line-number"},[n._v("9")]),e("br"),e("span",{staticClass:"line-number"},[n._v("10")]),e("br"),e("span",{staticClass:"line-number"},[n._v("11")]),e("br"),e("span",{staticClass:"line-number"},[n._v("12")]),e("br"),e("span",{staticClass:"line-number"},[n._v("13")]),e("br"),e("span",{staticClass:"line-number"},[n._v("14")]),e("br")])]),e("p",[n._v("由此可见，"),e("code",[n._v("PureComonent 和 Immutable.js")]),n._v(" 真是一对好基友！在实际的开发中，我们也确实经常左手 PureComonent，右手 Immutable.js，研发质量大大地提升呀！")]),n._v(" "),e("blockquote",[e("p",[n._v("值得注意的是，由于 "),e("code",[n._v("Immutable.js")]),n._v(" 存在一定的学习成本，并不是所有场景下都可以作为最优解被团队采纳。因此，一些团队也会基于 "),e("code",[n._v("PureComonent")]),n._v(" 和 "),e("code",[n._v("Immutable.js")]),n._v(" 去打造将两者结合的公共类，通过改写 setState 来提升研发体验，这也是不错的思路。")])]),n._v(" "),e("h2",{attrs:{id:"函数组件的性能优化：react-memo-和-usememo"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#函数组件的性能优化：react-memo-和-usememo"}},[n._v("#")]),n._v(" 函数组件的性能优化：React.memo 和 useMemo")]),n._v(" "),e("blockquote",[e("p",[n._v("以上咱们讨论的都是类组件的优化思路。那么在函数组件中，有没有什么通用的手段可以阻止“过度 re-render”的发生呢？接下来我们就一起认识一下“函数版”的 "),e("code",[n._v("shouldComponentUpdate/Purecomponent")]),n._v(" —— "),e("code",[n._v("React.memo")]),n._v("。")])]),n._v(" "),e("p",[e("strong",[n._v("React.memo：“函数版”shouldComponentUpdate/PureComponent")])]),n._v(" "),e("blockquote",[e("p",[e("code",[n._v("React.memo")]),n._v(" 是 React 导出的一个顶层函数，它本质上是一个高阶组件，负责对函数组件进行包装。基本的调用姿势如下面代码所示：")])]),n._v(" "),e("div",{staticClass:"language-react line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('import React from "react";\n// 定义一个函数组件\nfunction FunctionDemo(props) {\n  return xxx\n}\n// areEqual 函数是 memo 的第二个入参，我们之前放在 shouldComponentUpdate 里面的逻辑就可以转移至此处\nfunction areEqual(prevProps, nextProps) {\n  /*\n  return true if passing nextProps to render would return\n  the same result as passing prevProps to render,\n  otherwise return false\n  */\n}\n// 使用 React.memo 来包装函数组件\nexport default React.memo(FunctionDemo, areEqual);\n')])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br"),e("span",{staticClass:"line-number"},[n._v("9")]),e("br"),e("span",{staticClass:"line-number"},[n._v("10")]),e("br"),e("span",{staticClass:"line-number"},[n._v("11")]),e("br"),e("span",{staticClass:"line-number"},[n._v("12")]),e("br"),e("span",{staticClass:"line-number"},[n._v("13")]),e("br"),e("span",{staticClass:"line-number"},[n._v("14")]),e("br"),e("span",{staticClass:"line-number"},[n._v("15")]),e("br")])]),e("blockquote",[e("p",[e("code",[n._v("React.memo")]),n._v("会帮我们“记住”函数组件的渲染结果，在组件前后两次 "),e("code",[n._v("props")]),n._v(" 对比结果一致的情况下，它会直接复用最近一次渲染的结果。如果我们的组件在相同的 props 下会渲染相同的结果，那么使用 "),e("code",[n._v("React.memo")]),n._v(" 来包装它将是个不错的选择。")])]),n._v(" "),e("p",[n._v("从示例中我们可以看出，"),e("code",[n._v("React.memo")]),n._v(" 接收两个参数，"),e("code",[n._v("第一个参数是我们需要渲染的目标组件")]),n._v("，"),e("code",[n._v("第二个参数 areEqual 则用来承接 props 的对比逻辑")]),n._v("。之前我们在 "),e("code",[n._v("shouldComponentUpdate")]),n._v(" 里面做的事情，现在就可以放在 areEqual 里来做。")]),n._v(" "),e("p",[n._v("比如开篇 Demo 中的 ChildB 组件，就完全可以用 "),e("code",[n._v("Function Component + React.memo")]),n._v(" 来改造。改造后的 ChildB 代码如下：")]),n._v(" "),e("div",{staticClass:"language-react line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('import React from "react";\n\n// 将 ChildB 改写为 function 组件\nfunction ChildB(props) {\n  console.log("ChildB 的render 逻辑执行了");\n  return (\n    <div className="childB">\n      子组件B的内容：\n      {props.text}\n    </div>\n  );\n}\n\n// areEqual 用于对比 props 的变化\nfunction areEqual(prevProps, nextProps) {\n  if(prevProps.text === nextProps.text) {\n    return true\n  }\n  return false\n}\n\n// 使用 React.memo 来包装 ChildB\nexport default React.memo(ChildB, areEqual);\n')])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br"),e("span",{staticClass:"line-number"},[n._v("9")]),e("br"),e("span",{staticClass:"line-number"},[n._v("10")]),e("br"),e("span",{staticClass:"line-number"},[n._v("11")]),e("br"),e("span",{staticClass:"line-number"},[n._v("12")]),e("br"),e("span",{staticClass:"line-number"},[n._v("13")]),e("br"),e("span",{staticClass:"line-number"},[n._v("14")]),e("br"),e("span",{staticClass:"line-number"},[n._v("15")]),e("br"),e("span",{staticClass:"line-number"},[n._v("16")]),e("br"),e("span",{staticClass:"line-number"},[n._v("17")]),e("br"),e("span",{staticClass:"line-number"},[n._v("18")]),e("br"),e("span",{staticClass:"line-number"},[n._v("19")]),e("br"),e("span",{staticClass:"line-number"},[n._v("20")]),e("br"),e("span",{staticClass:"line-number"},[n._v("21")]),e("br"),e("span",{staticClass:"line-number"},[n._v("22")]),e("br"),e("span",{staticClass:"line-number"},[n._v("23")]),e("br")])]),e("blockquote",[e("p",[n._v("改造后的组件在效果上就等价于 "),e("code",[n._v("shouldComponentUpdate")]),n._v(" 加持后的类组件 "),e("code",[n._v("ChildB")])])]),n._v(" "),e("p",[n._v("这里的 "),e("code",[n._v("areEqual 函数是一个可选参数")]),n._v("，当我们不传入 "),e("code",[n._v("areEqual")]),n._v(" 时，"),e("code",[n._v("React.memo")]),n._v(" 也可以工作，此时它的作用就类似于 "),e("code",[n._v("PureComponent——React.memo")]),n._v(" 会自动为你的组件执行 "),e("code",[n._v("props 的浅比较逻辑")]),n._v("。")]),n._v(" "),e("blockquote",[e("p",[n._v("和 "),e("code",[n._v("shouldComponentUpdate")]),n._v(" 不同的是，"),e("code",[n._v("React.memo")]),n._v(" 只负责对比 "),e("code",[n._v("props")]),n._v("，而不会去感知组件内部状态（"),e("code",[n._v("state")]),n._v("）的变化")])]),n._v(" "),e("p",[e("strong",[n._v("useMemo：更加“精细”的 memo")])]),n._v(" "),e("blockquote",[e("p",[n._v("通过上面的分析我们知道，"),e("code",[n._v("React.memo")]),n._v(" 可以实现类似于 "),e("code",[n._v("shouldComponentUpdate")]),n._v(" 或者"),e("code",[n._v("PureComponent")]),n._v(" 的效果，对组件级别的 re-render 进行管控。但是有时候，我们希望复用的并不是整个组件，而是组件中的某一个或几个部分。这种更加“精细化”的管控，就需要 "),e("code",[n._v("useMemo")]),n._v(" 来帮忙了。")])]),n._v(" "),e("p",[e("strong",[n._v("简而言之")]),n._v("，"),e("code",[n._v("React.memo 控制是否需要重渲染一个组件")]),n._v("，而 "),e("code",[n._v("useMemo 控制的则是是否需要重复执行某一段逻辑")])]),n._v(" "),e("p",[e("code",[n._v("useMemo")]),n._v(" 的使用方式如下面代码所示：")]),n._v(" "),e("div",{staticClass:"language-react line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br")])]),e("blockquote",[e("p",[n._v("我们可以把目标逻辑作为第一个参数传入，把逻辑的依赖项数组作为第二个参数传入。这样只有当依赖项数组中的某个依赖发生变化时，"),e("code",[n._v("useMemo")]),n._v(" 才会重新执行第一个入参中的目标逻辑")])]),n._v(" "),e("p",[n._v("这里我仍然以开篇的示例为例，现在我尝试向 ChildB 中传入两个属性：text 和 count，它们分别是一段文本和一个数字。当我点击右边的按钮时，只有 count 数字会发生变化。改造后的 App 组件代码如下：")]),n._v(" "),e("div",{staticClass:"language-react line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("class App extends React.Component {\n  state = {\n    textA: '我是A的文本',\n    stateB: {\n      text: '我是B的文本',\n      count: 10\n    }\n  }\n  changeA = () => {\n    this.setState({\n      textA: 'A的文本被修改了'\n    })\n  }\n  changeB = () => {\n    this.setState({\n      stateB: {\n        ...this.state.stateB,\n        count: 100\n      }\n    })\n  }\n  render() {\n    return (\n    <div className=\"App\">\n      <div className=\"container\">\n        <button onClick={this.changeA}>点击修改A处的文本</button>\n        <button onClick={this.changeB}>点击修改B处的文本</button>\n        <ul>\n          <li>\n            <ChildA text={this.state.textA}/>\n          </li>\n        <li>\n          <ChildB {...this.state.stateB}/>\n        </li>\n        </ul>\n      </div>\n    </div>\n  );\n  }\n}\nexport default App;\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br"),e("span",{staticClass:"line-number"},[n._v("9")]),e("br"),e("span",{staticClass:"line-number"},[n._v("10")]),e("br"),e("span",{staticClass:"line-number"},[n._v("11")]),e("br"),e("span",{staticClass:"line-number"},[n._v("12")]),e("br"),e("span",{staticClass:"line-number"},[n._v("13")]),e("br"),e("span",{staticClass:"line-number"},[n._v("14")]),e("br"),e("span",{staticClass:"line-number"},[n._v("15")]),e("br"),e("span",{staticClass:"line-number"},[n._v("16")]),e("br"),e("span",{staticClass:"line-number"},[n._v("17")]),e("br"),e("span",{staticClass:"line-number"},[n._v("18")]),e("br"),e("span",{staticClass:"line-number"},[n._v("19")]),e("br"),e("span",{staticClass:"line-number"},[n._v("20")]),e("br"),e("span",{staticClass:"line-number"},[n._v("21")]),e("br"),e("span",{staticClass:"line-number"},[n._v("22")]),e("br"),e("span",{staticClass:"line-number"},[n._v("23")]),e("br"),e("span",{staticClass:"line-number"},[n._v("24")]),e("br"),e("span",{staticClass:"line-number"},[n._v("25")]),e("br"),e("span",{staticClass:"line-number"},[n._v("26")]),e("br"),e("span",{staticClass:"line-number"},[n._v("27")]),e("br"),e("span",{staticClass:"line-number"},[n._v("28")]),e("br"),e("span",{staticClass:"line-number"},[n._v("29")]),e("br"),e("span",{staticClass:"line-number"},[n._v("30")]),e("br"),e("span",{staticClass:"line-number"},[n._v("31")]),e("br"),e("span",{staticClass:"line-number"},[n._v("32")]),e("br"),e("span",{staticClass:"line-number"},[n._v("33")]),e("br"),e("span",{staticClass:"line-number"},[n._v("34")]),e("br"),e("span",{staticClass:"line-number"},[n._v("35")]),e("br"),e("span",{staticClass:"line-number"},[n._v("36")]),e("br"),e("span",{staticClass:"line-number"},[n._v("37")]),e("br"),e("span",{staticClass:"line-number"},[n._v("38")]),e("br"),e("span",{staticClass:"line-number"},[n._v("39")]),e("br"),e("span",{staticClass:"line-number"},[n._v("40")]),e("br"),e("span",{staticClass:"line-number"},[n._v("41")]),e("br")])]),e("p",[n._v("在 ChildB 中，使用 "),e("code",[n._v("useMemo")]),n._v(" 来加持 "),e("code",[n._v("text 和 count")]),n._v(" 各自的渲染逻辑。改造后的 ChildB 代码如下所示：")]),n._v(" "),e("div",{staticClass:"language-react line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('import React,{ useMemo } from "react";\nexport default function ChildB({text, count}) {\n  console.log("ChildB 的render 逻辑执行了");\n  // text 文本的渲染逻辑\n  const renderText = (text)=> {\n    console.log(\'renderText 执行了\')\n    return <p>\n    子组件B的文本内容：\n      {text}\n  </p>\n  }\n  // count 数字的渲染逻辑\n  const renderCount = (count) => {\n    console.log(\'renderCount 执行了\')\n    return <p>\n      子组件B的数字内容：\n        {count}\n    </p>\n  }\n\n  // 使用 useMemo 加持两段渲染逻辑\n  const textContent = useMemo(()=>renderText(text),[text])\n  const countContent = useMemo(()=>renderCount(count),[count])\n  return (\n    <div className="childB">\n      {textContent}\n      {countContent}\n    </div>\n  );\n}\n')])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br"),e("span",{staticClass:"line-number"},[n._v("9")]),e("br"),e("span",{staticClass:"line-number"},[n._v("10")]),e("br"),e("span",{staticClass:"line-number"},[n._v("11")]),e("br"),e("span",{staticClass:"line-number"},[n._v("12")]),e("br"),e("span",{staticClass:"line-number"},[n._v("13")]),e("br"),e("span",{staticClass:"line-number"},[n._v("14")]),e("br"),e("span",{staticClass:"line-number"},[n._v("15")]),e("br"),e("span",{staticClass:"line-number"},[n._v("16")]),e("br"),e("span",{staticClass:"line-number"},[n._v("17")]),e("br"),e("span",{staticClass:"line-number"},[n._v("18")]),e("br"),e("span",{staticClass:"line-number"},[n._v("19")]),e("br"),e("span",{staticClass:"line-number"},[n._v("20")]),e("br"),e("span",{staticClass:"line-number"},[n._v("21")]),e("br"),e("span",{staticClass:"line-number"},[n._v("22")]),e("br"),e("span",{staticClass:"line-number"},[n._v("23")]),e("br"),e("span",{staticClass:"line-number"},[n._v("24")]),e("br"),e("span",{staticClass:"line-number"},[n._v("25")]),e("br"),e("span",{staticClass:"line-number"},[n._v("26")]),e("br"),e("span",{staticClass:"line-number"},[n._v("27")]),e("br"),e("span",{staticClass:"line-number"},[n._v("28")]),e("br"),e("span",{staticClass:"line-number"},[n._v("29")]),e("br"),e("span",{staticClass:"line-number"},[n._v("30")]),e("br")])]),e("p",[n._v("渲染 App 组件，我们可以看到初次渲染时，renderText 和 renderCount 都执行了，控制台输出如下图所示：")]),n._v(" "),e("p",[e("img",{attrs:{src:"https://mmbiz.qpic.cn/sz_mmbiz_png/zHYsKHjf0njMyqe5C52rtuldYXB5qI1ibBt0NsX7NQz5J3eJ43dejhKXXvcySIGJ7zBlRkakpBGz0DVJwt4D86A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),n._v(" "),e("p",[n._v("点击右边按钮，对 count 进行修改，修改后的界面会发生如下的变化：")]),n._v(" "),e("p",[e("img",{attrs:{src:"https://mmbiz.qpic.cn/sz_mmbiz_png/zHYsKHjf0njMyqe5C52rtuldYXB5qI1ibA60ZBeROkbQf3WibEVczR4xwrsicYSO6OIyPCtAG6QafWGyV5SspbnAw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),n._v(" "),e("p",[n._v("可以看出，由于 "),e("code",[n._v("count")]),n._v(" 发生了变化，因此 "),e("code",[n._v("useMemo")]),n._v(" 针对 "),e("code",[n._v("renderCount")]),n._v(" 的逻辑进行了重计算。而 "),e("code",[n._v("text")]),n._v(" 没有发生变化，因此 "),e("code",[n._v("renderText")]),n._v(" 的逻辑压根没有执行。")]),n._v(" "),e("p",[n._v("使用 "),e("code",[n._v("useMemo")]),n._v("，我们可以对函数组件的执行逻辑进行更加细粒度的管控（尤其是定向规避掉一些高开销的计算），同时也弥补了 "),e("code",[n._v("React.memo")]),n._v(" 无法感知函数内部状态的遗憾，这对我们整体的性能提升是大有裨益的。")])])}),[],!1,null,null,null);s.default=a.exports}}]);