<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端查漏补缺 | 一只Chang</title>
    <meta name="generator" content="VuePress 1.4.1">
    <link rel="icon" href="/my-blog/favicon.ico">
    <meta name="description" content="Do not go gentle into that good night">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    <link rel="preload" href="/my-blog/assets/css/0.styles.157b7c22.css" as="style"><link rel="preload" href="/my-blog/assets/js/app.835ec0b2.js" as="script"><link rel="preload" href="/my-blog/assets/js/3.a3dfb6d1.js" as="script"><link rel="preload" href="/my-blog/assets/js/1.bd88c7fd.js" as="script"><link rel="preload" href="/my-blog/assets/js/22.e0423825.js" as="script"><link rel="prefetch" href="/my-blog/assets/js/10.a6cb310e.js"><link rel="prefetch" href="/my-blog/assets/js/11.15cbdce5.js"><link rel="prefetch" href="/my-blog/assets/js/12.fde9a3e5.js"><link rel="prefetch" href="/my-blog/assets/js/13.4156d5ca.js"><link rel="prefetch" href="/my-blog/assets/js/14.74d59886.js"><link rel="prefetch" href="/my-blog/assets/js/15.c3557164.js"><link rel="prefetch" href="/my-blog/assets/js/16.a29fc453.js"><link rel="prefetch" href="/my-blog/assets/js/17.4c0bff20.js"><link rel="prefetch" href="/my-blog/assets/js/18.e4d08395.js"><link rel="prefetch" href="/my-blog/assets/js/19.7dcb1080.js"><link rel="prefetch" href="/my-blog/assets/js/20.05f15efb.js"><link rel="prefetch" href="/my-blog/assets/js/21.8e607ccc.js"><link rel="prefetch" href="/my-blog/assets/js/23.764eedeb.js"><link rel="prefetch" href="/my-blog/assets/js/24.c141ab74.js"><link rel="prefetch" href="/my-blog/assets/js/25.5a28d671.js"><link rel="prefetch" href="/my-blog/assets/js/26.23ed4ac0.js"><link rel="prefetch" href="/my-blog/assets/js/27.e4e260c4.js"><link rel="prefetch" href="/my-blog/assets/js/28.c70c78ed.js"><link rel="prefetch" href="/my-blog/assets/js/29.02fa36c9.js"><link rel="prefetch" href="/my-blog/assets/js/30.e8bd4d7b.js"><link rel="prefetch" href="/my-blog/assets/js/31.1901f9de.js"><link rel="prefetch" href="/my-blog/assets/js/32.b3d349ff.js"><link rel="prefetch" href="/my-blog/assets/js/33.c01e57e7.js"><link rel="prefetch" href="/my-blog/assets/js/34.880bafdd.js"><link rel="prefetch" href="/my-blog/assets/js/35.c0ff8c00.js"><link rel="prefetch" href="/my-blog/assets/js/36.d61fea93.js"><link rel="prefetch" href="/my-blog/assets/js/37.d90d5819.js"><link rel="prefetch" href="/my-blog/assets/js/38.406179d5.js"><link rel="prefetch" href="/my-blog/assets/js/39.83c6d115.js"><link rel="prefetch" href="/my-blog/assets/js/4.1cd0d515.js"><link rel="prefetch" href="/my-blog/assets/js/40.5507824e.js"><link rel="prefetch" href="/my-blog/assets/js/41.f506efaf.js"><link rel="prefetch" href="/my-blog/assets/js/42.9d0a2fc8.js"><link rel="prefetch" href="/my-blog/assets/js/43.c1a9be14.js"><link rel="prefetch" href="/my-blog/assets/js/44.08fa353d.js"><link rel="prefetch" href="/my-blog/assets/js/5.a3a85aa4.js"><link rel="prefetch" href="/my-blog/assets/js/6.6839a5a0.js"><link rel="prefetch" href="/my-blog/assets/js/7.5d85a00b.js"><link rel="prefetch" href="/my-blog/assets/js/8.9cf8a355.js"><link rel="prefetch" href="/my-blog/assets/js/9.6148638a.js">
    <link rel="stylesheet" href="/my-blog/assets/css/0.styles.157b7c22.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-c00e2ab0><div data-v-c00e2ab0><div id="loader-wrapper" class="loading-wrapper" data-v-2c578df8 data-v-c00e2ab0 data-v-c00e2ab0><div class="loader-main" data-v-2c578df8><div data-v-2c578df8></div><div data-v-2c578df8></div><div data-v-2c578df8></div><div data-v-2c578df8></div></div> <!----> <!----></div> <div class="password-shadow password-wrapper-out" style="display:none;" data-v-4a776749 data-v-c00e2ab0 data-v-c00e2ab0><h3 class="title" style="display:none;" data-v-4a776749 data-v-4a776749>一只Chang</h3> <!----> <label id="box" class="inputBox" style="display:none;" data-v-4a776749 data-v-4a776749><input type="password" value="" data-v-4a776749> <span data-v-4a776749>Konck! Knock!</span> <button data-v-4a776749>OK</button></label> <div class="footer" style="display:none;" data-v-4a776749 data-v-4a776749><span data-v-4a776749><i class="iconfont reco-theme" data-v-4a776749></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-4a776749>vuePress-theme-reco</a></span> <span data-v-4a776749><i class="iconfont reco-copyright" data-v-4a776749></i> <a data-v-4a776749><span data-v-4a776749>一只Chang</span>
            
          <span data-v-4a776749>2019 - </span>
          2022
        </a></span></div></div> <div class="hide" data-v-c00e2ab0><header class="navbar" data-v-c00e2ab0><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/my-blog/" class="home-link router-link-active"><img src="/my-blog/logo.png" alt="一只Chang" class="logo"> <span class="site-name">一只Chang</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/my-blog/" class="nav-link"><i class="iconfont reco-home"></i>
  Home
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      Category
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/my-blog/categories/面试/" class="nav-link"><i class="iconfont undefined"></i>
  面试
</a></li><li class="dropdown-item"><!----> <a href="/my-blog/categories/js/" class="nav-link"><i class="iconfont undefined"></i>
  js
</a></li><li class="dropdown-item"><!----> <a href="/my-blog/categories/Vue/" class="nav-link"><i class="iconfont undefined"></i>
  Vue
</a></li><li class="dropdown-item"><!----> <a href="/my-blog/categories/前端/" class="nav-link"><i class="iconfont undefined"></i>
  前端
</a></li><li class="dropdown-item"><!----> <a href="/my-blog/categories/开发/" class="nav-link"><i class="iconfont undefined"></i>
  开发
</a></li><li class="dropdown-item"><!----> <a href="/my-blog/categories/基础/" class="nav-link"><i class="iconfont undefined"></i>
  基础
</a></li><li class="dropdown-item"><!----> <a href="/my-blog/categories/TypeScript/" class="nav-link"><i class="iconfont undefined"></i>
  TypeScript
</a></li><li class="dropdown-item"><!----> <a href="/my-blog/categories/学习笔记/" class="nav-link"><i class="iconfont undefined"></i>
  学习笔记
</a></li><li class="dropdown-item"><!----> <a href="/my-blog/categories/总结/" class="nav-link"><i class="iconfont undefined"></i>
  总结
</a></li><li class="dropdown-item"><!----> <a href="/my-blog/categories/React/" class="nav-link"><i class="iconfont undefined"></i>
  React
</a></li><li class="dropdown-item"><!----> <a href="/my-blog/categories/git/" class="nav-link"><i class="iconfont undefined"></i>
  git
</a></li><li class="dropdown-item"><!----> <a href="/my-blog/categories/vue/" class="nav-link"><i class="iconfont undefined"></i>
  vue
</a></li><li class="dropdown-item"><!----> <a href="/my-blog/categories/开发笔记/" class="nav-link"><i class="iconfont undefined"></i>
  开发笔记
</a></li><li class="dropdown-item"><!----> <a href="/my-blog/categories/uniapp/" class="nav-link"><i class="iconfont undefined"></i>
  uniapp
</a></li></ul></div></div><div class="nav-item"><a href="/my-blog/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tag
</a></div><div class="nav-item"><a href="/my-blog/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      Contact
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/cj620" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-c00e2ab0></div> <aside class="sidebar" data-v-c00e2ab0><div class="personal-info-wrapper" data-v-1285c3cd><img src="/my-blog/avatar.png" alt="author-avatar" class="personal-img" data-v-1285c3cd> <h3 class="name" data-v-1285c3cd>
    一只Chang
  </h3> <div class="num" data-v-1285c3cd><div data-v-1285c3cd><h3 data-v-1285c3cd>32</h3> <h6 data-v-1285c3cd>Article</h6></div> <div data-v-1285c3cd><h3 data-v-1285c3cd>21</h3> <h6 data-v-1285c3cd>Tag</h6></div></div> <hr data-v-1285c3cd></div> <nav class="nav-links"><div class="nav-item"><a href="/my-blog/" class="nav-link"><i class="iconfont reco-home"></i>
  Home
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      Category
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/my-blog/categories/面试/" class="nav-link"><i class="iconfont undefined"></i>
  面试
</a></li><li class="dropdown-item"><!----> <a href="/my-blog/categories/js/" class="nav-link"><i class="iconfont undefined"></i>
  js
</a></li><li class="dropdown-item"><!----> <a href="/my-blog/categories/Vue/" class="nav-link"><i class="iconfont undefined"></i>
  Vue
</a></li><li class="dropdown-item"><!----> <a href="/my-blog/categories/前端/" class="nav-link"><i class="iconfont undefined"></i>
  前端
</a></li><li class="dropdown-item"><!----> <a href="/my-blog/categories/开发/" class="nav-link"><i class="iconfont undefined"></i>
  开发
</a></li><li class="dropdown-item"><!----> <a href="/my-blog/categories/基础/" class="nav-link"><i class="iconfont undefined"></i>
  基础
</a></li><li class="dropdown-item"><!----> <a href="/my-blog/categories/TypeScript/" class="nav-link"><i class="iconfont undefined"></i>
  TypeScript
</a></li><li class="dropdown-item"><!----> <a href="/my-blog/categories/学习笔记/" class="nav-link"><i class="iconfont undefined"></i>
  学习笔记
</a></li><li class="dropdown-item"><!----> <a href="/my-blog/categories/总结/" class="nav-link"><i class="iconfont undefined"></i>
  总结
</a></li><li class="dropdown-item"><!----> <a href="/my-blog/categories/React/" class="nav-link"><i class="iconfont undefined"></i>
  React
</a></li><li class="dropdown-item"><!----> <a href="/my-blog/categories/git/" class="nav-link"><i class="iconfont undefined"></i>
  git
</a></li><li class="dropdown-item"><!----> <a href="/my-blog/categories/vue/" class="nav-link"><i class="iconfont undefined"></i>
  vue
</a></li><li class="dropdown-item"><!----> <a href="/my-blog/categories/开发笔记/" class="nav-link"><i class="iconfont undefined"></i>
  开发笔记
</a></li><li class="dropdown-item"><!----> <a href="/my-blog/categories/uniapp/" class="nav-link"><i class="iconfont undefined"></i>
  uniapp
</a></li></ul></div></div><div class="nav-item"><a href="/my-blog/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tag
</a></div><div class="nav-item"><a href="/my-blog/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      Contact
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/cj620" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>前端查漏补缺</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#_1-如何在es5环境下实现let" class="sidebar-link">1. 如何在ES5环境下实现let</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#_2-如何在es5环境下实现const" class="sidebar-link">2. 如何在ES5环境下实现const</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#_3-手写call" class="sidebar-link">3. 手写call()</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#_4-手写apply" class="sidebar-link">4. 手写apply()</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#_5-手写bind" class="sidebar-link">5. 手写bind()</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#_6-手写一个防抖函数" class="sidebar-link">6. 手写一个防抖函数</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#_7-手写一个节流函数" class="sidebar-link">7. 手写一个节流函数</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#_8-数组扁平化" class="sidebar-link">8. 数组扁平化</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#_9-手写一个promise" class="sidebar-link">9. 手写一个Promise</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#_1-模拟实现new" class="sidebar-link">1. 模拟实现new</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#_2-es5如何实现继承" class="sidebar-link">2. ES5如何实现继承</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/my-blog/views/category1/2020/basicKnowledge.html#一-原型链继承" class="sidebar-link">一. 原型链继承</a></li><li class="sidebar-sub-header"><a href="/my-blog/views/category1/2020/basicKnowledge.html#二-构造函数继承" class="sidebar-link">二. 构造函数继承</a></li><li class="sidebar-sub-header"><a href="/my-blog/views/category1/2020/basicKnowledge.html#三-组合式继承" class="sidebar-link">三. 组合式继承</a></li><li class="sidebar-sub-header"><a href="/my-blog/views/category1/2020/basicKnowledge.html#四-寄生式组合继承" class="sidebar-link">四. 寄生式组合继承</a></li></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#_1-v8如何执行一段js代码" class="sidebar-link">1. V8如何执行一段JS代码</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#_2-介绍一下引用计数和标记清除" class="sidebar-link">2. 介绍一下引用计数和标记清除</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#_3-v8如何进行垃圾回收" class="sidebar-link">3. V8如何进行垃圾回收</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#_4-js相较于c-等语言为什么慢，v8做了哪些优化" class="sidebar-link">4. JS相较于C++等语言为什么慢，V8做了哪些优化</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#_1-浏览器的渲染过程是怎样的" class="sidebar-link">1. 浏览器的渲染过程是怎样的</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#_2-如何根据浏览器渲染机制加快首屏速度" class="sidebar-link">2. 如何根据浏览器渲染机制加快首屏速度</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#_3-什么是回流-重排-，什么情况下会触发回流" class="sidebar-link">3. 什么是回流(重排)，什么情况下会触发回流</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#_4-什么是重绘，什么情况下会触发重绘" class="sidebar-link">4. 什么是重绘，什么情况下会触发重绘</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#_5-什么是gpu加速，如何使用gpu加速，gpu加速的缺点" class="sidebar-link">5. 什么是GPU加速，如何使用GPU加速，GPU加速的缺点</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#_6-如何减少回流" class="sidebar-link">6. 如何减少回流</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#_1-介绍一下浏览器缓存位置和优先级" class="sidebar-link">1. 介绍一下浏览器缓存位置和优先级</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#_2-说说不同缓存间的差别" class="sidebar-link">2. 说说不同缓存间的差别</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#_3-介绍一下浏览器缓存策略" class="sidebar-link">3. 介绍一下浏览器缓存策略</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#_1-讲讲网络osi七层模型，tcp-ip和http分别位于哪一层" class="sidebar-link">1. 讲讲网络OSI七层模型，TCP/IP和HTTP分别位于哪一层</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#_2-常见http状态码有哪些" class="sidebar-link">2. 常见HTTP状态码有哪些</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#_3-get请求和post请求有何区别" class="sidebar-link">3. GET请求和POST请求有何区别</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#_4-http的请求报文由哪几部分组成" class="sidebar-link">4. HTTP的请求报文由哪几部分组成</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#_5-http常见请求-响应头及其含义" class="sidebar-link">5. HTTP常见请求/响应头及其含义</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#_6-http-1-0和http-1-1有什么区别" class="sidebar-link">6. HTTP/1.0和HTTP/1.1有什么区别</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#_7-介绍一下http-2-0新特性" class="sidebar-link">7. 介绍一下HTTP/2.0新特性</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#_8-说说http-2-0多路复用基本原理以及解决的问题" class="sidebar-link">8. 说说HTTP/2.0多路复用基本原理以及解决的问题</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#_9-说说http-3-0" class="sidebar-link">9. 说说HTTP/3.0</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#_10-http和https有何区别" class="sidebar-link">10. HTTP和HTTPS有何区别</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#_11-https是如何进行加密的" class="sidebar-link">11. HTTPS是如何进行加密的</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#什么是csrf攻击" class="sidebar-link">什么是CSRF攻击</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#如何防御csrf攻击" class="sidebar-link">如何防御CSRF攻击</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#什么是xss攻击" class="sidebar-link">什么是XSS攻击</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#xss攻击有哪些类型" class="sidebar-link">XSS攻击有哪些类型</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#如何防御xss攻击" class="sidebar-link">如何防御XSS攻击</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#_1-手写冒泡排序" class="sidebar-link">1. 手写冒泡排序</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#_2-如何优化一个冒泡排序" class="sidebar-link">2. 如何优化一个冒泡排序</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#_3-手写快速排序" class="sidebar-link">3. 手写快速排序</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#_4-如何优化一个快速排序" class="sidebar-link">4. 如何优化一个快速排序</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#_5-手写归并排序" class="sidebar-link">5. 手写归并排序</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#_6-手写堆排序" class="sidebar-link">6. 手写堆排序</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#_7-归并、快排、堆排有何区别" class="sidebar-link">7. 归并、快排、堆排有何区别</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#_1-介绍一下单一职责原则和开放封闭原则" class="sidebar-link">1. 介绍一下单一职责原则和开放封闭原则</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#_2-单例模式" class="sidebar-link">2. 单例模式</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#_3-工厂模式" class="sidebar-link">3. 工厂模式</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#_4-观察者模式" class="sidebar-link">4. 观察者模式</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#_5-装饰器模式" class="sidebar-link">5. 装饰器模式</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#_6-适配器模式" class="sidebar-link">6. 适配器模式</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#_7-代理模式" class="sidebar-link">7. 代理模式</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#_1-说说html5在标签、属性、存储、api上的新特性" class="sidebar-link">1. 说说HTML5在标签、属性、存储、API上的新特性</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#_2-doctype的作用是什么？" class="sidebar-link">2. doctype的作用是什么？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#_3-几种前端储存以及它们之间的区别" class="sidebar-link">3. 几种前端储存以及它们之间的区别</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#_4-href和src有什么区别" class="sidebar-link">4. href和src有什么区别</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#_5-meta有哪些属性，作用是什么" class="sidebar-link">5. meta有哪些属性，作用是什么</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#_6-viewport有哪些参数，作用是什么" class="sidebar-link">6. viewport有哪些参数，作用是什么</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#_7-http-equive属性的作用和参数" class="sidebar-link">7. http-equive属性的作用和参数</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#清除浮动的方法" class="sidebar-link">清除浮动的方法</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#介绍一下flex布局" class="sidebar-link">介绍一下flex布局</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#常见布局" class="sidebar-link">常见布局</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#什么是bfc" class="sidebar-link">什么是BFC</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#如何触发bfc" class="sidebar-link">如何触发BFC</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#bfc的渲染规则是什么" class="sidebar-link">BFC的渲染规则是什么</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/my-blog/views/category1/2020/basicKnowledge.html#bfc的应用场景" class="sidebar-link">BFC的应用场景</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-4a776749 data-v-c00e2ab0><h3 class="title" style="display:none;" data-v-4a776749 data-v-4a776749>前端查漏补缺</h3> <!----> <label id="box" class="inputBox" style="display:none;" data-v-4a776749 data-v-4a776749><input type="password" value="" data-v-4a776749> <span data-v-4a776749>Konck! Knock!</span> <button data-v-4a776749>OK</button></label> <div class="footer" style="display:none;" data-v-4a776749 data-v-4a776749><span data-v-4a776749><i class="iconfont reco-theme" data-v-4a776749></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-4a776749>vuePress-theme-reco</a></span> <span data-v-4a776749><i class="iconfont reco-copyright" data-v-4a776749></i> <a data-v-4a776749><span data-v-4a776749>一只Chang</span>
            
          <span data-v-4a776749>2019 - </span>
          2022
        </a></span></div></div> <div data-v-c00e2ab0><main class="page"><div class="page-title" style="display:none;"><h1>前端查漏补缺</h1> <hr> <div data-v-ba876724><i class="iconfont reco-account" data-v-ba876724><span data-v-ba876724>一只Chang</span></i> <i class="iconfont reco-date" data-v-ba876724><span data-v-ba876724>2020-10-23</span></i> <i class="iconfont reco-eye" data-v-ba876724><span id="/my-blog/views/category1/2020/basicKnowledge.html" data-flag-title="Your Article Title" class="leancloud-visitors" data-v-ba876724><a class="leancloud-visitors-count" style="font-size:.9rem;font-weight:normal;color:#999;"></a></span></i> <i class="iconfont reco-tag tags" data-v-ba876724><span class="tag-item" data-v-ba876724>
      知识点
    </span></i></div></div> <div class="theme-reco-content content__default" style="display:none;"><h1 id="js基础"><a href="#js基础" class="header-anchor">#</a> JS基础</h1> <h2 id="_1-如何在es5环境下实现let"><a href="#_1-如何在es5环境下实现let" class="header-anchor">#</a> 1. 如何在ES5环境下实现let</h2> <blockquote><p>这个问题实质上是在回答<code>let</code>和<code>var</code>有什么区别，对于这个问题，我们可以直接查看<code>babel</code>转换前后的结果，看一下在循环中通过<code>let</code>定义的变量是如何解决变量提升的问题</p></blockquote> <p><img src="https://user-gold-cdn.xitu.io/2020/4/5/1714616e2fd53bf8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p> <p>babel在let定义的变量前加了道下划线，避免在块级作用域外访问到该变量，除了对变量名的转换，我们也可以通过自执行函数来模拟块级作用域</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>(function(){
  for(var i = 0; i &lt; 5; i ++){
    console.log(i)  // 0 1 2 3 4
  }
})();

console.log(i)      // Uncaught ReferenceError: i is not defined
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>不过这个问题并没有结束，我们回到<code>var</code>和<code>let/const</code>的区别上：</p> <ul><li><code>var</code>声明的变量会挂到window上，而<code>let</code>和<code>const</code>不会</li> <li><code>var</code>声明的变量存在变量提升，而<code>let</code>和<code>const</code>不会</li> <li><code>let</code>和<code>const</code>声明形成块作用域，只能在块作用域里访问，不能跨块访问，也不能跨函数访问</li> <li>同一作用域下<code>let</code>和<code>const</code>不能声明同名变量，而<code>var</code>可以</li> <li>暂时性死区，<code>let</code>和<code>const</code>声明的变量不能在声明前被使用</li></ul> <p>babel的转化，其实只实现了第2、3、5点</p> <h2 id="_2-如何在es5环境下实现const"><a href="#_2-如何在es5环境下实现const" class="header-anchor">#</a> 2. 如何在ES5环境下实现const</h2> <p>实现const的关键在于<code>Object.defineProperty()</code>这个API，这个API用于在一个对象上增加或修改属性。通过配置属性描述符，可以精确地控制属性行为。<code>Object.defineProperty()</code> 接收三个参数：</p> <blockquote><p>Object.defineProperty(obj, prop, desc)</p></blockquote> <table><thead><tr><th>参数</th> <th>说明</th></tr></thead> <tbody><tr><td>obj</td> <td>要在其上定义属性的对象</td></tr> <tr><td>prop</td> <td>要定义或修改的属性的名称</td></tr> <tr><td>descriptor</td> <td>将被定义或修改的属性描述符</td></tr></tbody></table> <table><thead><tr><th>属性描述符</th> <th>说明</th> <th>默认值</th></tr></thead> <tbody><tr><td>value</td> <td>该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined</td> <td>undefined</td></tr> <tr><td>get</td> <td>一个给属性提供 getter 的方法，如果没有 getter 则为 undefined</td> <td>undefined</td></tr> <tr><td>set</td> <td>一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。当属性值修改时，触发执行该方法</td> <td>undefined</td></tr> <tr><td>writable</td> <td>当且仅当该属性的writable为true时，value才能被赋值运算符改变。默认为 false</td> <td>false</td></tr> <tr><td>enumerable</td> <td>enumerable定义了对象的属性是否可以在 for...in 循环和 Object.keys() 中被枚举</td> <td>false</td></tr> <tr><td>Configurable</td> <td>configurable特性表示对象的属性是否可以被删除，以及除value和writable特性外的其他特性是否可以被修改</td> <td>false</td></tr></tbody></table> <p>对于const不可修改的特性，我们通过设置writable属性来实现</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function _const(key, value) {    
    const desc = {        
        value,        
        writable: false    
    }    
    Object.defineProperty(window, key, desc)
}
    
_const('obj', {a: 1})   //定义obj
obj.b = 2               //可以正常给obj的属性赋值
obj = {}                //无法赋值新对象
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>参考资料：<a href="https://juejin.im/post/6844903848008482824" target="_blank" rel="noopener noreferrer">如何在 ES5 环境下实现一个const ？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="_3-手写call"><a href="#_3-手写call" class="header-anchor">#</a> 3. 手写call()</h2> <blockquote><div class="language- line-numbers-mode"><pre class="language-text"><code>call() 方法`使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数
语法：`function.call(thisArg, arg1, arg2, ...)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></blockquote> <p><code>call()</code>的原理比较简单，由于函数的this指向它的直接调用者，我们变更调用者即完成this指向的变更：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>//变更函数调用者示例
function foo() {
    console.log(this.name)
}

// 测试
const obj = {
    name: '写代码像蔡徐抻'
}
obj.foo = foo   // 变更foo的调用者
obj.foo()       // '写代码像蔡徐抻'
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>基于以上原理, 我们两句代码就能实现call()</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Function.prototype.myCall = function(thisArg, ...args) {
    thisArg.fn = this              // this指向调用call的对象,即我们要改变this指向的函数
    return thisArg.fn(...args)     // 执行函数并return其执行结果
}
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>但是我们有一些细节需要处理：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Function.prototype.myCall = function(thisArg, ...args) {
    const fn = Symbol('fn')        // 声明一个独有的Symbol属性, 防止fn覆盖已有属性
    thisArg = thisArg || window    // 若没有传入this, 默认绑定window对象
    thisArg[fn] = this              // this指向调用call的对象,即我们要改变this指向的函数
    const result = thisArg[fn](...args)  // 执行当前函数
    delete thisArg[fn]              // 删除我们声明的fn属性
    return result                  // 返回函数执行结果
}

//测试
foo.myCall(obj)     // 输出'写代码像蔡徐抻'
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h2 id="_4-手写apply"><a href="#_4-手写apply" class="header-anchor">#</a> 4. 手写apply()</h2> <blockquote><p>apply() 方法调用一个具有给定this值的函数，以及作为一个数组（或类似数组对象）提供的参数。
语法：func.apply(thisArg, [argsArray])</p></blockquote> <p><code>apply()</code>和<code>call()</code>类似，区别在于call()接收参数列表，而apply()接收一个参数数组，所以我们在call()的实现上简单改一下入参形式即可</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Function.prototype.myApply = function(thisArg, args) {
    const fn = Symbol('fn')        // 声明一个独有的Symbol属性, 防止fn覆盖已有属性
    thisArg = thisArg || window    // 若没有传入this, 默认绑定window对象
    thisArg[fn] = this              // this指向调用call的对象,即我们要改变this指向的函数
    const result = thisArg[fn](...args)  // 执行当前函数（此处说明一下：虽然apply()接收的是一个数组，但在调用原函数时，依然要展开参数数组。可以对照原生apply()，原函数接收到展开的参数数组）
    delete thisArg[fn]              // 删除我们声明的fn属性
    return result                  // 返回函数执行结果
}

//测试
foo.myApply(obj, [])     // 输出'写代码像蔡徐抻'
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h2 id="_5-手写bind"><a href="#_5-手写bind" class="header-anchor">#</a> 5. 手写bind()</h2> <blockquote><p><code>bind()</code> 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。
语法: function.bind(thisArg, arg1, arg2, ...)</p></blockquote> <p>从用法上看，似乎给call/apply包一层function就实现了bind()：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Function.prototype.myBind = function(thisArg, ...args) {
    return () =&gt; {
        this.apply(thisArg, args)
    }
}
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>但我们忽略了三点：</p> <ol><li>bind()除了this还接收其他参数，bind()返回的函数也接收参数，这两部分的参数都要传给返回的函数</li> <li>new会改变this指向：如果bind绑定后的函数被new了，那么this指向会发生改变，指向当前函数的实例</li> <li>没有保留原函数在原型链上的属性和方法</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>Function.prototype.myBind = function (thisArg, ...args) {
    var self = this
    // new优先级
    var fbound = function () {
        self.apply(this instanceof self ? this : thisArg, args.concat(Array.prototype.slice.call(arguments)))
    }
    // 继承原型上的属性和方法
    fbound.prototype = Object.create(self.prototype);

    return fbound;
}

//测试
const obj = { name: '写代码像蔡徐抻' }
function foo() {
    console.log(this.name)
    console.log(arguments)
}

foo.myBind(obj, 'a', 'b', 'c')()    //输出写代码像蔡徐抻 ['a', 'b', 'c']
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><h2 id="_6-手写一个防抖函数"><a href="#_6-手写一个防抖函数" class="header-anchor">#</a> 6. 手写一个防抖函数</h2> <p>防抖和节流的概念都比较简单，所以我们就不在“防抖节流是什么”这个问题上浪费过多篇幅了，简单点一下：</p> <blockquote><p>防抖，即<code>短时间内大量触发同一事件，只会执行一次函数</code>，实现原理为<code>设置一个定时器，约定在xx毫秒后再触发事件处理，每次触发事件都会重新设置计时器，直到xx毫秒内无第二次操作</code>，防抖常用于搜索框/滚动条的监听事件处理，如果不做防抖，每输入一个字/滚动屏幕，都会触发事件处理，造成性能浪费。</p></blockquote> <div class="language- line-numbers-mode"><pre class="language-text"><code>function debounce(func, wait) {
    let timeout = null
    return function() {
        let context = this
        let args = arguments
        if (timeout) clearTimeout(timeout)
        timeout = setTimeout(() =&gt; {
            func.apply(context, args)
        }, wait)
    }
}
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h2 id="_7-手写一个节流函数"><a href="#_7-手写一个节流函数" class="header-anchor">#</a> 7. 手写一个节流函数</h2> <blockquote><p>防抖是<code>延迟执行</code>，而节流是<code>间隔执行</code>，函数节流即<code>每隔一段时间就执行一次</code>，实现原理为<code>设置一个定时器，约定xx毫秒后执行事件，如果时间到了，那么执行函数并重置定时器</code>，和防抖的区别在于，防抖每次触发事件都重置定时器，而节流在定时器到时间后再清空定时器</p></blockquote> <div class="language- line-numbers-mode"><pre class="language-text"><code>function throttle(func, wait) {
    let timeout = null
    return function() {
        let context = this
        let args = arguments
        if (!timeout) {
            timeout = setTimeout(() =&gt; {
                timeout = null
                func.apply(context, args)
            }, wait)
        }

    }
}
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><blockquote><p>实现方式2：使用两个时间戳<code>prev旧时间戳</code>和<code>now新时间戳</code>，每次触发事件都判断二者的时间差，如果到达规定时间，执行函数并重置旧时间戳</p></blockquote> <div class="language- line-numbers-mode"><pre class="language-text"><code>function throttle(func, wait) {
    var prev = 0;
    return function() {
        let now = Date.now();
        let context = this;
        let args = arguments;
        if (now - prev &gt; wait) {
            func.apply(context, args);
            prev = now;
        }
    }
}
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h2 id="_8-数组扁平化"><a href="#_8-数组扁平化" class="header-anchor">#</a> 8. 数组扁平化</h2> <blockquote><p>对于<code>[1, [1,2], [1,2,3]]</code>这样多层嵌套的数组，我们如何将其扁平化为<code>[1, 1, 2, 1, 2, 3]</code>这样的一维数组呢：</p></blockquote> <p><strong>1.ES6的flat()</strong></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const arr = [1, [1,2], [1,2,3]]
arr.flat(Infinity)  // [1, 1, 2, 1, 2, 3]
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>2.序列化后正则</strong></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const arr = [1, [1,2], [1,2,3]]
const str = `[${JSON.stringify(arr).replace(/(\[|\])/g, '')}]`
JSON.parse(str)   // [1, 1, 2, 1, 2, 3]
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><strong>3.递归</strong>
对于树状结构的数据，最直接的处理方式就是递归</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const arr = [1, [1,2], [1,2,3]]
function flat(arr) {
  let result = []
  for (const item of arr) {
    item instanceof Array ? result = result.concat(flat(item)) : result.push(item)
  }
  return result
}

flat(arr) // [1, 1, 2, 1, 2, 3]
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p><strong>4.reduce()递归</strong></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const arr = [1, [1,2], [1,2,3]]
function flat(arr) {
  return arr.reduce((prev, cur) =&gt; {
    return prev.concat(cur instanceof Array ? flat(cur) : cur)
  }, [])
}

flat(arr)  // [1, 1, 2, 1, 2, 3]
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><strong>5.迭代+展开运算符</strong></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 每次while都会合并一层的元素，这里第一次合并结果为[1, 1, 2, 1, 2, 3, [4,4,4]]
// 然后arr.some判定数组中是否存在数组，因为存在[4,4,4]，继续进入第二次循环进行合并
let arr = [1, [1,2], [1,2,3,[4,4,4]]]
while (arr.some(Array.isArray)) {
  arr = [].concat(...arr);
}

console.log(arr)  // [1, 1, 2, 1, 2, 3, 4, 4, 4]
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="_9-手写一个promise"><a href="#_9-手写一个promise" class="header-anchor">#</a> 9. 手写一个Promise</h2> <blockquote><p>实现一个符合规范的Promise篇幅比较长，建议阅读笔者上一篇文章：<a href="https://juejin.im/post/6844904096525189128" target="_blank" rel="noopener noreferrer">异步编程二三事 | Promise/async/Generator实现原理解析 | 9k字<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></blockquote> <h1 id="js面向对象"><a href="#js面向对象" class="header-anchor">#</a> JS面向对象</h1> <p>在JS中一切皆对象，但JS并不是一种真正的面向对象(OOP)的语言，因为它缺少<code>类(class)</code>的概念。虽然ES6引入了<code>class</code>和<code>extends</code>，使我们能够轻易地实现类和继承。但JS并不存在真实的类，JS的类是通过函数以及原型链机制模拟的，本小节的就来探究如何在ES5环境下利用函数和原型链实现JS面向对象的特性</p> <p>在开始之前，我们先回顾一下原型链的知识，后续<code>new</code>和<code>继承</code>等实现都是基于原型链机制。很多介绍原型链的资料都能写上洋洋洒洒几千字，但我觉得读者们不需要把原型链想太复杂，容易把自己绕进去，其实在我看来，原型链的核心只需要记住三点：</p> <ol><li>每个对象都有<code>__proto__属性</code>，该属性指向其原型对象，在调用实例的方法和属性时，如果在实例对象上找不到，就会往原型对象上找</li> <li>构造函数的<code>prototype属性</code>也指向实例的原型对象</li> <li>原型对象的<code>constructor属性</code>指向构造函数</li></ol> <p><img src="https://user-gold-cdn.xitu.io/2020/4/4/17144d68b7d0eea1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p> <h2 id="_1-模拟实现new"><a href="#_1-模拟实现new" class="header-anchor">#</a> 1. 模拟实现new</h2> <p>首先我们要知道<code>new</code>做了什么</p> <ol><li><strong>创建一个新对象，并继承其构造函数的<code>prototype</code></strong>，这一步是为了继承构造函数原型上的属性和方法</li> <li><strong>执行构造函数，方法内的<code>this</code>被指定为该新实例</strong>，这一步是为了执行构造函数内的赋值操作</li> <li><strong>返回新实例</strong>（规范规定，如果构造方法返回了一个对象，那么返回该对象，否则返回第一步创建的新对象）</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>// new是关键字,这里我们用函数来模拟,new Foo(args) &lt;=&gt; myNew(Foo, args)
function myNew(foo, ...args) {
  // 创建新对象,并继承构造方法的prototype属性, 这一步是为了把obj挂原型链上, 相当于obj.__proto__ = Foo.prototype
  let obj = Object.create(foo.prototype)  
  
  // 执行构造方法, 并为其绑定新this, 这一步是为了让构造方法能进行this.name = name之类的操作, args是构造方法的入参, 因为这里用myNew模拟, 所以入参从myNew传入
  let result = foo.apply(obj, args)

  // 如果构造方法已经return了一个对象，那么就返回该对象，否则返回myNew创建的新对象（一般情况下，构造方法不会返回新实例，但使用者可以选择返回新实例来覆盖new创建的对象）
  return Object.prototype.toString.call(result) === '[object Object]' ? result : obj
}

// 测试：
function Foo(name) {
  this.name = name
}
const newObj = myNew(Foo, 'zhangsan')
console.log(newObj)                 // Foo {name: &quot;zhangsan&quot;}
console.log(newObj instanceof Foo)  // true
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><h2 id="_2-es5如何实现继承"><a href="#_2-es5如何实现继承" class="header-anchor">#</a> 2. ES5如何实现继承</h2> <p>说到继承，最容易想到的是ES6的<code>extends</code>，当然如果只回答这个肯定不合格，我们要从函数和原型链的角度上实现继承，下面我们一步步地、递进地实现一个合格的继承</p> <h3 id="一-原型链继承"><a href="#一-原型链继承" class="header-anchor">#</a> 一. 原型链继承</h3> <p>原型链继承的原理很简单，直接让子类的原型对象指向父类实例，当子类实例找不到对应的属性和方法时，就会往它的原型对象，也就是父类实例上找，从而实现对父类的属性和方法的继承</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 父类
function Parent() {
    this.name = '写代码像蔡徐抻'
}
// 父类的原型方法
Parent.prototype.getName = function() {
    return this.name
}
// 子类
function Child() {}

// 让子类的原型对象指向父类实例, 这样一来在Child实例中找不到的属性和方法就会到原型对象(父类实例)上寻找
Child.prototype = new Parent()
Child.prototype.constructor = Child // 根据原型链的规则,顺便绑定一下constructor, 这一步不影响继承, 只是在用到constructor时会需要

// 然后Child实例就能访问到父类及其原型上的name属性和getName()方法
const child = new Child()
child.name          // '写代码像蔡徐抻'
child.getName()     // '写代码像蔡徐抻'
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><blockquote><p>原型继承的缺点:</p></blockquote> <ol><li>由于所有Child实例原型都指向同一个Parent实例, 因此对某个Child实例的父类引用类型变量修改会影响所有的Child实例</li> <li>在创建子类实例时无法向父类构造传参, 即没有实现<code>super()</code>的功能</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 示例:
function Parent() {
    this.name = ['写代码像蔡徐抻'] 
}
Parent.prototype.getName = function() {
    return this.name
}
function Child() {}

Child.prototype = new Parent()
Child.prototype.constructor = Child 

// 测试
const child1 = new Child()
const child2 = new Child()
child1.name[0] = 'foo'
console.log(child1.name)          // ['foo']
console.log(child2.name)          // ['foo'] (预期是['写代码像蔡徐抻'], 对child1.name的修改引起了所有child实例的变化)
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><h3 id="二-构造函数继承"><a href="#二-构造函数继承" class="header-anchor">#</a> 二. 构造函数继承</h3> <p>构造函数继承，即在子类的构造函数中执行父类的构造函数，并为其绑定子类的<code>this</code>，让父类的构造函数把成员属性和方法都挂到<code>子类的this</code>上去，这样既能避免实例之间共享一个原型实例，又能向父类构造方法传参</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function Parent(name) {
    this.name = [name]
}
Parent.prototype.getName = function() {
    return this.name
}
function Child() {
    Parent.call(this, 'zhangsan')   // 执行父类构造方法并绑定子类的this, 使得父类中的属性能够赋到子类的this上
}

//测试
const child1 = new Child()
const child2 = new Child()
child1.name[0] = 'foo'
console.log(child1.name)          // ['foo']
console.log(child2.name)          // ['zhangsan']
child2.getName()                  // 报错,找不到getName(), 构造函数继承的方式继承不到父类原型上的属性和方法
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><blockquote><p>构造函数继承的缺点:</p></blockquote> <ol><li>继承不到父类原型上的属性和方法</li></ol> <h3 id="三-组合式继承"><a href="#三-组合式继承" class="header-anchor">#</a> 三. 组合式继承</h3> <p>既然原型链继承和构造函数继承各有互补的优缺点, 那么我们为什么不组合起来使用呢, 所以就有了综合二者的组合式继承</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function Parent(name) {
    this.name = [name]
}
Parent.prototype.getName = function() {
    return this.name
}
function Child() {
    // 构造函数继承
    Parent.call(this, 'zhangsan') 
}
//原型链继承
Child.prototype = new Parent()
Child.prototype.constructor = Child

//测试
const child1 = new Child()
const child2 = new Child()
child1.name[0] = 'foo'
console.log(child1.name)          // ['foo']
console.log(child2.name)          // ['zhangsan']
child2.getName()                  // ['zhangsan']
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><blockquote><p>组合式继承的缺点:</p></blockquote> <ol><li>每次创建子类实例都执行了两次构造函数(<code>Parent.call()</code>和<code>new Parent()</code>)，虽然这并不影响对父类的继承，但子类创建实例时，原型中会存在两份相同的属性和方法，这并不优雅</li></ol> <h3 id="四-寄生式组合继承"><a href="#四-寄生式组合继承" class="header-anchor">#</a> 四. 寄生式组合继承</h3> <p>为了解决构造函数被执行两次的问题, 我们将<code>指向父类实例</code>改为<code>指向父类原型</code>, 减去一次构造函数的执行</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function Parent(name) {
    this.name = [name]
}
Parent.prototype.getName = function() {
    return this.name
}
function Child() {
    // 构造函数继承
    Parent.call(this, 'zhangsan') 
}
//原型链继承
// Child.prototype = new Parent()
Child.prototype = Parent.prototype  //将`指向父类实例`改为`指向父类原型`
Child.prototype.constructor = Child

//测试
const child1 = new Child()
const child2 = new Child()
child1.name[0] = 'foo'
console.log(child1.name)          // ['foo']
console.log(child2.name)          // ['zhangsan']
child2.getName()                  // ['zhangsan']
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><p>但这种方式存在一个问题，由于子类原型和父类原型指向同一个对象，我们对子类原型的操作会影响到父类原型，例如给<code>Child.prototype</code>增加一个getName()方法，那么会导致<code>Parent.prototype</code>也增加或被覆盖一个getName()方法，为了解决这个问题，我们给<code>Parent.prototype</code>做一个浅拷贝</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function Parent(name) {
    this.name = [name]
}
Parent.prototype.getName = function() {
    return this.name
}
function Child() {
    // 构造函数继承
    Parent.call(this, 'zhangsan') 
}
//原型链继承
// Child.prototype = new Parent()
Child.prototype = Object.create(Parent.prototype)  //将`指向父类实例`改为`指向父类原型`
Child.prototype.constructor = Child

//测试
const child = new Child()
const parent = new Parent()
child.getName()                  // ['zhangsan']
parent.getName()                 // 报错, 找不到getName()
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>到这里我们就完成了ES5环境下的继承的实现，这种继承方式称为<code>寄生组合式继承</code>，是目前最成熟的继承方式，babel对ES6继承的转化也是使用了寄生组合式继承</p> <p>我们回顾一下实现过程：
一开始最容易想到的是<code>原型链继承</code>，通过把子类实例的原型指向父类实例来继承父类的属性和方法，但原型链继承的缺陷在于<code>对子类实例继承的引用类型的修改会影响到所有的实例对象</code>以及<code>无法向父类的构造方法传参</code>。
因此我们引入了<code>构造函数继承</code>, 通过在子类构造函数中调用父类构造函数并传入子类this来获取父类的属性和方法，但构造函数继承也存在缺陷，构造函数继承<code>不能继承到父类原型链上的属性和方法</code>。
所以我们综合了两种继承的优点，提出了<code>组合式继承</code>，但组合式继承也引入了新的问题，它<code>每次创建子类实例都执行了两次父类构造方法</code>，我们通过将<code>子类原型指向父类实例</code>改为<code>子类原型指向父类原型的浅拷贝</code>来解决这一问题，也就是最终实现 —— <code>寄生组合式继承</code></p> <p><img src="https://user-gold-cdn.xitu.io/2020/4/6/1714fd86c8983189?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p> <h1 id="v8引擎机制"><a href="#v8引擎机制" class="header-anchor">#</a> V8引擎机制</h1> <h2 id="_1-v8如何执行一段js代码"><a href="#_1-v8如何执行一段js代码" class="header-anchor">#</a> 1. V8如何执行一段JS代码</h2> <p><img src="https://user-gold-cdn.xitu.io/2020/2/5/1701324268cca319?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p> <ol><li><strong>预解析</strong>：检查语法错误但不生成AST</li> <li><strong>生成AST</strong>：经过词法/语法分析，生成抽象语法树</li> <li><strong>生成字节码</strong>：基线编译器(Ignition)将AST转换成字节码</li> <li><strong>生成机器码</strong>：优化编译器(Turbofan)将字节码转换成优化过的机器码，此外在逐行执行字节码的过程中，如果一段代码经常被执行，那么V8会将这段代码直接转换成机器码保存起来，下一次执行就不必经过字节码，优化了执行速度</li></ol> <p>上面几点只是V8执行机制的极简总结，建议阅读参考资料：</p> <blockquote><p>1.<a href="https://juejin.im/post/6844903990073753613" target="_blank" rel="noopener noreferrer">V8 是怎么跑起来的 —— V8 的 JavaScript 执行管道<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>
2.<a href="https://juejin.im/post/6844904021451505677" target="_blank" rel="noopener noreferrer">JavaScript 引擎 V8 执行流程概述<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></blockquote> <h2 id="_2-介绍一下引用计数和标记清除"><a href="#_2-介绍一下引用计数和标记清除" class="header-anchor">#</a> 2. 介绍一下引用计数和标记清除</h2> <ul><li><strong>引用计数</strong>：给一个变量赋值引用类型，则该对象的引用次数+1，如果这个变量变成了其他值，那么该对象的引用次数-1，垃圾回收器会回收引用次数为0的对象。但是当对象循环引用时，会导致引用次数永远无法归零，造成内存无法释放。</li> <li><strong>标记清除</strong>：垃圾收集器先给内存中所有对象加上标记，然后从根节点开始遍历，去掉被引用的对象和运行环境中对象的标记，剩下的被标记的对象就是无法访问的等待回收的对象。</li></ul> <h2 id="_3-v8如何进行垃圾回收"><a href="#_3-v8如何进行垃圾回收" class="header-anchor">#</a> 3. V8如何进行垃圾回收</h2> <p>JS引擎中对变量的存储主要有两种位置，栈内存和堆内存，栈内存存储基本类型数据以及引用类型数据的内存地址，堆内存储存引用类型的数据</p> <p><img src="https://user-gold-cdn.xitu.io/2020/4/5/17149730709e41a4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p> <blockquote><p>栈内存的回收：</p></blockquote> <p>栈内存调用栈上下文切换后就被回收，比较简单</p> <blockquote><p>堆内存的回收：</p></blockquote> <p>V8的堆内存分为新生代内存和老生代内存，新生代内存是临时分配的内存，存在时间短，老生代内存存在时间长</p> <p><img src="https://user-gold-cdn.xitu.io/2020/4/5/1714980cac75fc32?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p> <ul><li>新生代内存回收机制：
<ul><li>新生代内存容量小，64位系统下仅有32M。新生代内存分为<strong>From、To</strong>两部分，进行垃圾回收时，先扫描From，将非存活对象回收，将存活对象顺序复制到To中，之后调换From/To，等待下一次回收</li></ul></li> <li>老生代内存回收机制
<ul><li><strong>晋升</strong>：如果新生代的变量经过多次回收依然存在，那么就会被放入老生代内存中</li> <li><strong>标记清除</strong>：老生代内存会先遍历所有对象并打上标记，然后对正在使用或被强引用的对象取消标记，回收被标记的对象</li> <li><strong>整理内存碎片</strong>：把对象挪到内存的一端</li></ul></li></ul> <blockquote><p>参考资料：<a href="https://juejin.im/post/6844903591510016007#heading-10" target="_blank" rel="noopener noreferrer">聊聊V8引擎的垃圾回收<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></blockquote> <h2 id="_4-js相较于c-等语言为什么慢，v8做了哪些优化"><a href="#_4-js相较于c-等语言为什么慢，v8做了哪些优化" class="header-anchor">#</a> 4. JS相较于C++等语言为什么慢，V8做了哪些优化</h2> <ol><li>JS的问题：
<ul><li><strong>动态类型</strong>：导致每次存取属性/寻求方法时候，都需要先检查类型；此外动态类型也很难在编译阶段进行优化</li> <li><strong>属性存取</strong>：C++/Java等语言中方法、属性是存储在数组中的，仅需数组位移就可以获取，而JS存储在对象中，每次获取都要进行哈希查询</li></ul></li> <li>V8的优化：
<ul><li><strong>优化JIT(即时编译)</strong>：相较于C++/Java这类编译型语言，JS一边解释一边执行，效率低。V8对这个过程进行了优化：如果一段代码被执行多次，那么V8会把这段代码转化为机器码缓存下来，下次运行时直接使用机器码。</li> <li><strong>隐藏类</strong>：对于C++这类语言来说，仅需几个指令就能通过偏移量获取变量信息，而JS需要进行字符串匹配，效率低，V8借用了类和偏移位置的思想，将对象划分成不同的组，即隐藏类</li> <li><strong>内嵌缓存</strong>：即缓存对象查询的结果。常规查询过程是：获取隐藏类地址 -&gt; 根据属性名查找偏移值 -&gt; 计算该属性地址，内嵌缓存就是对这一过程结果的缓存</li> <li><strong>垃圾回收管理</strong>：上文已介绍</li></ul></li></ol> <p>![img](data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1280" height="824"></svg>)</p> <blockquote><p>参考资料：<a href="https://zhuanlan.zhihu.com/p/27628685" target="_blank" rel="noopener noreferrer">为什么V8引擎这么快？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></blockquote> <h1 id="浏览器渲染机制"><a href="#浏览器渲染机制" class="header-anchor">#</a> 浏览器渲染机制</h1> <h2 id="_1-浏览器的渲染过程是怎样的"><a href="#_1-浏览器的渲染过程是怎样的" class="header-anchor">#</a> 1. 浏览器的渲染过程是怎样的</h2> <p>![img](data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1280" height="604"></svg>)</p> <p>大体流程如下：</p> <ol><li>HTML和CSS经过各自解析，生成DOM树和CSSOM树</li> <li>合并成为渲染树</li> <li>根据渲染树进行布局</li> <li>最后调用GPU进行绘制，显示在屏幕上</li></ol> <h2 id="_2-如何根据浏览器渲染机制加快首屏速度"><a href="#_2-如何根据浏览器渲染机制加快首屏速度" class="header-anchor">#</a> 2. 如何根据浏览器渲染机制加快首屏速度</h2> <ol><li><strong>优化文件大小</strong>：HTML和CSS的加载和解析都会阻塞渲染树的生成，从而影响首屏展示速度，因此我们可以通过优化文件大小、减少CSS文件层级的方法来加快首屏速度</li> <li><strong>避免资源下载阻塞文档解析</strong>：浏览器解析到<script></script></li></ol></div> <footer class="page-edit" style="display:none;"><!----> <!----></footer> <!----> <!----></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-a008c6ba data-v-a008c6ba><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-a008c6ba><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-a008c6ba></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-a008c6ba></path></svg></div></div></div>
    <script src="/my-blog/assets/js/app.835ec0b2.js" defer></script><script src="/my-blog/assets/js/3.a3dfb6d1.js" defer></script><script src="/my-blog/assets/js/1.bd88c7fd.js" defer></script><script src="/my-blog/assets/js/22.e0423825.js" defer></script>
  </body>
</html>
